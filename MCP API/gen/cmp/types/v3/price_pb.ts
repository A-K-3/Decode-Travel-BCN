// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=.js"
// @generated from file cmp/types/v3/price.proto (package cmp.types.v3, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { PriceBreakdownType } from "../v1/price_type_pb.js";
import { file_cmp_types_v1_price_type } from "../v1/price_type_pb.js";
import type { Currency } from "./currency_pb.js";
import { file_cmp_types_v3_currency } from "./currency_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cmp/types/v3/price.proto.
 */
export const file_cmp_types_v3_price: GenFile = /*@__PURE__*/
  fileDesc("ChhjbXAvdHlwZXMvdjMvcHJpY2UucHJvdG8SDGNtcC50eXBlcy52MyLPAQoLUHJpY2VEZXRhaWwSIgoFcHJpY2UYASABKAsyEy5jbXAudHlwZXMudjMuUHJpY2USDwoHYmluZGluZxgCIAEoCBITCgtkZXNjcmlwdGlvbhgDIAEoCRIXCg9sb2NhbGx5X3BheWFibGUYBCABKAgSLgoEdHlwZRgFIAEoCzIgLmNtcC50eXBlcy52MS5QcmljZUJyZWFrZG93blR5cGUSLQoKYnJlYWtkb3ducxgGIAMoCzIZLmNtcC50eXBlcy52My5QcmljZURldGFpbCJSCgVQcmljZRINCgV2YWx1ZRgBIAEoCRIQCghkZWNpbWFscxgCIAEoBRIoCghjdXJyZW5jeRgDIAEoCzIWLmNtcC50eXBlcy52My5DdXJyZW5jeWIGcHJvdG8z", [file_cmp_types_v1_price_type, file_cmp_types_v3_currency]);

/**
 * ### PriceDetail
 *
 * This message consists of the value as a Price object and additional fields as
 * binding, concept, and breakdown.
 *
 * Breakdown is a recursively inherited object of PriceDetail. This way complex
 * pricing structures can be represented.
 *
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/c4t/proto/cmp/types/v3/price.proto.dot.xs.svg)
 *
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/c4t/proto/cmp/types/v3/price.proto.dot.svg)
 *
 * @generated from message cmp.types.v3.PriceDetail
 */
export type PriceDetail = Message<"cmp.types.v3.PriceDetail"> & {
  /**
   * Principle price element
   *
   * @generated from field: cmp.types.v3.Price price = 1;
   */
  price?: Price;

  /**
   * Identification whether the price must be respected towards the end-user
   * and the product or service cannot be offered for a lower price.
   *
   * @generated from field: bool binding = 2;
   */
  binding: boolean;

  /**
   * Description of the product or service this price(element) is valid for.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * If not specified, the default of the boolean is false which means it is
   * included in the price. If set to True, it means that this PriceDetail is only
   * payable locally. For example local tourism tax that you pay at the reception of
   * a hotel. Intended to be used in the breakdown.
   *
   * @generated from field: bool locally_payable = 4;
   */
  locallyPayable: boolean;

  /**
   * Type of price breakdown. This is meant to be used in price breakdown
   * definitions, when we want to specify the different elements of how a total
   * price was computed.
   *
   * @generated from field: cmp.types.v1.PriceBreakdownType type = 5;
   */
  type?: PriceBreakdownType;

  /**
   * We can use a single PriceDetail to represent a price breakdown.
   *
   * @generated from field: repeated cmp.types.v3.PriceDetail breakdowns = 6;
   */
  breakdowns: PriceDetail[];
};

/**
 * Describes the message cmp.types.v3.PriceDetail.
 * Use `create(PriceDetailSchema)` to create a new message.
 */
export const PriceDetailSchema: GenMessage<PriceDetail> = /*@__PURE__*/
  messageDesc(file_cmp_types_v3_price, 0);

/**
 * ### Simple Price type message Price
 *
 * Value of the price, represented as an integer converted to string.
 *
 * This field is intentionally a string. Since currency can be cryptocurrency
 * with up to 18 decimal places precision, we need a reliable way to represent
 * large integers without precision loss.
 *
 * Definition of the price message: The combination of "value" and "decimals" fields
 * always expresses the value of the currency itself, not its smallest fraction
 * (e.g., ETH not wei, CAM not aCAM, BTC not Satoshi, EUR not EUR-Cents).
 * Partners should avoid rounding with cryptocurrencies.
 *
 * Example implementations:
 *
 * Off-chain payment of 100 â‚¬ or 100 $:
 * value=10000, decimals=2, iso_currency=EUR or USD
 *
 * On-chain payment of 100.65 EURSH:
 * value=10065, decimals=2, contract_address=0x...
 * This currency has 5 decimals on Columbus and Camino. To create the transaction value,
 * 10065 must be divided by 10^2 = 100.65 EURSH, then represented in its smallest
 * fraction by multiplying 100.65 EURSH * 10^5 => 10065000
 * (Example conversion to bigint without losing accuracy: bigint(10065) * 10^(5-2))
 *
 * On-chain payment of 0.0065 BTC:
 * value=65, decimals=4, contract_address=0x...
 * Using the contract address, we retrieve the decimals and currency name: 8 decimals & WBTC
 * With 4 decimals specified in the message, we divide 65 by 10^4 == 0.0065 WBTC
 * (for display in UIs)
 *
 * For on-chain operations, this value must be converted to its smallest unit as:
 * bigint(65) * 10^(8-4) == 650000
 *
 * On-chain payment of 1 nCAM:
 * value=1, decimals=9
 * This currency has denominator 18 on Columbus and Camino. To mint 1 nCam, it must be
 * divided by 10^9 = The currency has denominator 18 on
 * Columbus. To mint 1 nCam, divide by 10^9 = 0.000000001 CAM, then express in its
 * smallest fraction by multiplying 0.000000001 * 10^18 => 1000000000 aCAM
 *
 * For the "currency" field, the Currency message provides a "one-of" option to specify:
 * - Traditional fiat currency (EUR, USD, CHF) according to ISO codes
 * - Native Camino and Columbus blockchain currency (CAM)
 * - ERC20 digital currencies like stablecoins (EURe, EURSH, EURC, USDC), Volatile
 *   coins (BTC, AVAX) and Loyalty points (Aventus/AVT for events, Plutus/PLU from
 *   Visa, AVA from Travala, Blackbird's FLY)
 *
 * The value of loyalty points must be verifiable or agreed between partners.
 * Partial payment combining loyalty points with fiat or ERC20 currencies in a
 * single transaction is not yet implemented.
 *
 * As a Distributor, look up the configured currencies your Suppliers support
 * in their CM Account configuration. For ERC20 currencies or loyalty points,
 * the EVM contract address must be supplied in the Search Request. This address
 * can be found in the Supplier's CM account and must be verified as authentic.
 *
 * Distributors must acquire necessary funds and transfer them to their CM Account
 * for on-chain payments.
 *
 * Suppliers verify the received currency in the search request and, if supported,
 * process the request to respond in the requested currency. If the currency is
 * not recognized or supported, an error is returned.
 *
 * Partner Plugins for both Distributors and Suppliers should be able to map
 * CAM or other digital currencies with EVM Contract addresses to their respective
 * currency entities in the back office system.
 *
 * @generated from message cmp.types.v3.Price
 */
export type Price = Message<"cmp.types.v3.Price"> & {
  /**
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * @generated from field: int32 decimals = 2;
   */
  decimals: number;

  /**
   * @generated from field: cmp.types.v3.Currency currency = 3;
   */
  currency?: Currency;
};

/**
 * Describes the message cmp.types.v3.Price.
 * Use `create(PriceSchema)` to create a new message.
 */
export const PriceSchema: GenMessage<Price> = /*@__PURE__*/
  messageDesc(file_cmp_types_v3_price, 1);

