// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/location.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Length } from "./measurement_pb";
import { Country } from "../v2/country_pb";

/**
 * Location Code Type
 *
 * @generated from enum cmp.types.v4.LocationCodeType
 */
export enum LocationCodeType {
  /**
   * @generated from enum value: LOCATION_CODE_TYPE_UNSPECIFIED = 0;
   */
  LOCATION_CODE_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOCATION_CODE_TYPE_PROVIDER_CODE = 1;
   */
  LOCATION_CODE_TYPE_PROVIDER_CODE = 1,

  /**
   * IATA airport code
   *
   * @generated from enum value: LOCATION_CODE_TYPE_IATA_CODE = 2;
   */
  LOCATION_CODE_TYPE_IATA_CODE = 2,

  /**
   * ICAO airport code
   *
   * @generated from enum value: LOCATION_CODE_TYPE_ICAO_CODE = 3;
   */
  LOCATION_CODE_TYPE_ICAO_CODE = 3,

  /**
   * A 3-character code used for train stations. Previously referred to as CRS
   * (Computer Reservation System) or NRS (National Reservation System) codes.
   *
   * @generated from enum value: LOCATION_CODE_TYPE_3ALPHA_CODE = 4;
   */
  LOCATION_CODE_TYPE_3ALPHA_CODE = 4,

  /**
   * A 6-digit code for train stations generally used for retail purposes
   *
   * @generated from enum value: LOCATION_CODE_TYPE_NLC_CODE = 5;
   */
  LOCATION_CODE_TYPE_NLC_CODE = 5,

  /**
   * Codes relating to points used in deriving train schedules
   *
   * @generated from enum value: LOCATION_CODE_TYPE_TIPLOC_CODE = 6;
   */
  LOCATION_CODE_TYPE_TIPLOC_CODE = 6,

  /**
   * These codes can refer to locations such as sidings and junctions. STANOX codes
   * are grouped by geographical area - the first two digits specify the area in
   * which the location exists.
   *
   * @generated from enum value: LOCATION_CODE_TYPE_STANOX_CODE = 7;
   */
  LOCATION_CODE_TYPE_STANOX_CODE = 7,

  /**
   * Used by multi-modal journey planners and timetables
   *
   * @generated from enum value: LOCATION_CODE_TYPE_ATCO_CODE = 8;
   */
  LOCATION_CODE_TYPE_ATCO_CODE = 8,

  /**
   * Used in combination with the Google Places API
   *
   * @generated from enum value: LOCATION_CODE_TYPE_GOOGLE_PLACE_ID = 9;
   */
  LOCATION_CODE_TYPE_GOOGLE_PLACE_ID = 9,

  /**
   * Used in combination with the Foursquare Places API
   *
   * @generated from enum value: LOCATION_CODE_TYPE_FOURSQUARE_FSQ_ID = 10;
   */
  LOCATION_CODE_TYPE_FOURSQUARE_FSQ_ID = 10,

  /**
   * Used in combination with the OSM Overpass API
   *
   * @generated from enum value: LOCATION_CODE_TYPE_OPENSTREETMAPS_REF = 11;
   */
  LOCATION_CODE_TYPE_OPENSTREETMAPS_REF = 11,

  /**
   * Used in combination with the HERE Places API
   *
   * @generated from enum value: LOCATION_CODE_TYPE_HERE_ID = 12;
   */
  LOCATION_CODE_TYPE_HERE_ID = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(LocationCodeType)
proto3.util.setEnumType(LocationCodeType, "cmp.types.v4.LocationCodeType", [
  { no: 0, name: "LOCATION_CODE_TYPE_UNSPECIFIED" },
  { no: 1, name: "LOCATION_CODE_TYPE_PROVIDER_CODE" },
  { no: 2, name: "LOCATION_CODE_TYPE_IATA_CODE" },
  { no: 3, name: "LOCATION_CODE_TYPE_ICAO_CODE" },
  { no: 4, name: "LOCATION_CODE_TYPE_3ALPHA_CODE" },
  { no: 5, name: "LOCATION_CODE_TYPE_NLC_CODE" },
  { no: 6, name: "LOCATION_CODE_TYPE_TIPLOC_CODE" },
  { no: 7, name: "LOCATION_CODE_TYPE_STANOX_CODE" },
  { no: 8, name: "LOCATION_CODE_TYPE_ATCO_CODE" },
  { no: 9, name: "LOCATION_CODE_TYPE_GOOGLE_PLACE_ID" },
  { no: 10, name: "LOCATION_CODE_TYPE_FOURSQUARE_FSQ_ID" },
  { no: 11, name: "LOCATION_CODE_TYPE_OPENSTREETMAPS_REF" },
  { no: 12, name: "LOCATION_CODE_TYPE_HERE_ID" },
]);

/**
 * Represents geographic coordinates, specified by latitude and longitude.
 * 
 * These coordinates define a single point on the Earth's surface.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/location.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/location.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.Coordinates
 */
export class Coordinates extends Message<Coordinates> {
  /**
   * The latitude, in degrees. Must be between -90.0 and +90.0.
   *
   * @generated from field: double latitude = 1;
   */
  latitude = 0;

  /**
   * The longitude, in degrees. Must be between -180.0 and +180.0.
   *
   * @generated from field: double longitude = 2;
   */
  longitude = 0;

  constructor(data?: PartialMessage<Coordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Coordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Coordinates {
    return new Coordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Coordinates {
    return new Coordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Coordinates {
    return new Coordinates().fromJsonString(jsonString, options);
  }

  static equals(a: Coordinates | PlainMessage<Coordinates> | undefined, b: Coordinates | PlainMessage<Coordinates> | undefined): boolean {
    return proto3.util.equals(Coordinates, a, b);
  }
}

/**
 * Represents a geographic area defined by a circle.
 * 
 * This is useful for searching or specifying locations within a certain distance
 * from a central point.
 *
 * @generated from message cmp.types.v4.GeoCircle
 */
export class GeoCircle extends Message<GeoCircle> {
  /**
   * The central point of the circle.
   *
   * @generated from field: cmp.types.v4.Coordinates center = 1;
   */
  center?: Coordinates;

  /**
   * The radius of the circle.
   *
   * @generated from field: cmp.types.v4.Length radius = 2;
   */
  radius?: Length;

  constructor(data?: PartialMessage<GeoCircle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.GeoCircle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "center", kind: "message", T: Coordinates },
    { no: 2, name: "radius", kind: "message", T: Length },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoCircle {
    return new GeoCircle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoCircle {
    return new GeoCircle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoCircle {
    return new GeoCircle().fromJsonString(jsonString, options);
  }

  static equals(a: GeoCircle | PlainMessage<GeoCircle> | undefined, b: GeoCircle | PlainMessage<GeoCircle> | undefined): boolean {
    return proto3.util.equals(GeoCircle, a, b);
  }
}

/**
 * Represents a geographic area defined by a polygon.
 * 
 * This is useful for specifying complex or irregular areas on a map.
 *
 * @generated from message cmp.types.v4.GeoPolygon
 */
export class GeoPolygon extends Message<GeoPolygon> {
  /**
   * A list of geographic points defining the vertices of the polygon.
   * The points should typically be ordered sequentially to define the polygon's
   * boundary. The polygon is implicitly closed.
   * Must contain at least 3 points to form a valid polygon.
   *
   * @generated from field: repeated cmp.types.v4.Coordinates points = 1;
   */
  points: Coordinates[] = [];

  constructor(data?: PartialMessage<GeoPolygon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.GeoPolygon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: Coordinates, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPolygon {
    return new GeoPolygon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPolygon {
    return new GeoPolygon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPolygon {
    return new GeoPolygon().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPolygon | PlainMessage<GeoPolygon> | undefined, b: GeoPolygon | PlainMessage<GeoPolygon> | undefined): boolean {
    return proto3.util.equals(GeoPolygon, a, b);
  }
}

/**
 * Geo Tree
 * 
 * Contrary to Geo coordinates, circle and polygon, a geotree is supplier specific
 * and would require mapping for every connection. If possible use generic concepts,
 * so that implementations can easily be reused among suppliers.
 *
 * @generated from message cmp.types.v4.GeoTree
 */
export class GeoTree extends Message<GeoTree> {
  /**
   * @generated from field: cmp.types.v2.Country country = 1;
   */
  country = Country.UNSPECIFIED;

  /**
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * @generated from field: string city_or_resort = 3;
   */
  cityOrResort = "";

  constructor(data?: PartialMessage<GeoTree>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.GeoTree";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "country", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "city_or_resort", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoTree {
    return new GeoTree().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoTree {
    return new GeoTree().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoTree {
    return new GeoTree().fromJsonString(jsonString, options);
  }

  static equals(a: GeoTree | PlainMessage<GeoTree> | undefined, b: GeoTree | PlainMessage<GeoTree> | undefined): boolean {
    return proto3.util.equals(GeoTree, a, b);
  }
}

/**
 * Represents a location identified by a specific code and code type.
 * 
 * Location codes can be standardized (like IATA airport codes) or specific to
 * a particular provider or system.
 *
 * @generated from message cmp.types.v4.LocationCode
 */
export class LocationCode extends Message<LocationCode> {
  /**
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * @generated from field: cmp.types.v4.LocationCodeType type = 2;
   */
  type = LocationCodeType.LOCATION_CODE_TYPE_UNSPECIFIED;

  constructor(data?: PartialMessage<LocationCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.LocationCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(LocationCodeType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationCode {
    return new LocationCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationCode {
    return new LocationCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationCode {
    return new LocationCode().fromJsonString(jsonString, options);
  }

  static equals(a: LocationCode | PlainMessage<LocationCode> | undefined, b: LocationCode | PlainMessage<LocationCode> | undefined): boolean {
    return proto3.util.equals(LocationCode, a, b);
  }
}

/**
 * A wrapper message containing a list of `LocationCode` messages.
 * 
 * This wrapper is primarily used to allow a list of `LocationCode` messages to be
 * included as a member of a `oneof` field, which does not natively support repeated
 * fields.
 *
 * @generated from message cmp.types.v4.LocationCodes
 */
export class LocationCodes extends Message<LocationCodes> {
  /**
   * @generated from field: repeated cmp.types.v4.LocationCode codes = 1;
   */
  codes: LocationCode[] = [];

  constructor(data?: PartialMessage<LocationCodes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.LocationCodes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "codes", kind: "message", T: LocationCode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationCodes {
    return new LocationCodes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationCodes {
    return new LocationCodes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationCodes {
    return new LocationCodes().fromJsonString(jsonString, options);
  }

  static equals(a: LocationCodes | PlainMessage<LocationCodes> | undefined, b: LocationCodes | PlainMessage<LocationCodes> | undefined): boolean {
    return proto3.util.equals(LocationCodes, a, b);
  }
}

