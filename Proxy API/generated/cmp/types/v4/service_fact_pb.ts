// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/service_fact.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { PriceDetail } from "./price_pb";
import { LocalizedString } from "./localized_pb";

/**
 * @generated from enum cmp.types.v4.ServiceAvailabilityType
 */
export enum ServiceAvailabilityType {
  /**
   * @generated from enum value: SERVICE_AVAILABILITY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SERVICE_AVAILABILITY_TYPE_INCLUDED = 1;
   */
  INCLUDED = 1,

  /**
   * @generated from enum value: SERVICE_AVAILABILITY_TYPE_COMPULSORY = 2;
   */
  COMPULSORY = 2,

  /**
   * @generated from enum value: SERVICE_AVAILABILITY_TYPE_OPTIONAL = 3;
   */
  OPTIONAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ServiceAvailabilityType)
proto3.util.setEnumType(ServiceAvailabilityType, "cmp.types.v4.ServiceAvailabilityType", [
  { no: 0, name: "SERVICE_AVAILABILITY_TYPE_UNSPECIFIED" },
  { no: 1, name: "SERVICE_AVAILABILITY_TYPE_INCLUDED" },
  { no: 2, name: "SERVICE_AVAILABILITY_TYPE_COMPULSORY" },
  { no: 3, name: "SERVICE_AVAILABILITY_TYPE_OPTIONAL" },
]);

/**
 * @generated from enum cmp.types.v4.ChargeBasisType
 */
export enum ChargeBasisType {
  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_PER_PAX = 1;
   */
  PER_PAX = 1,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_PER_PAX_PER_DAY = 2;
   */
  PER_PAX_PER_DAY = 2,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_PER_UNIT = 3;
   */
  PER_UNIT = 3,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_PER_UNIT_PER_DAY = 4;
   */
  PER_UNIT_PER_DAY = 4,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_PER_DAY = 5;
   */
  PER_DAY = 5,

  /**
   * @generated from enum value: CHARGE_BASIS_TYPE_ONCE = 6;
   */
  ONCE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ChargeBasisType)
proto3.util.setEnumType(ChargeBasisType, "cmp.types.v4.ChargeBasisType", [
  { no: 0, name: "CHARGE_BASIS_TYPE_UNSPECIFIED" },
  { no: 1, name: "CHARGE_BASIS_TYPE_PER_PAX" },
  { no: 2, name: "CHARGE_BASIS_TYPE_PER_PAX_PER_DAY" },
  { no: 3, name: "CHARGE_BASIS_TYPE_PER_UNIT" },
  { no: 4, name: "CHARGE_BASIS_TYPE_PER_UNIT_PER_DAY" },
  { no: 5, name: "CHARGE_BASIS_TYPE_PER_DAY" },
  { no: 6, name: "CHARGE_BASIS_TYPE_ONCE" },
]);

/**
 * Service fact message type
 * Service facts are smaller services that are included, can be booked optionally
 * or must be booked together with a main product or service. For example on Christmas
 * eve a gala dinner is included in the stay. Or an early check-in can be booked when
 * travellers have an early flight. Or cleaning cost must be included for every booking
 * of a holiday home.
 * 
 * It is important that these optional, included or compulsory services are simple. For
 * complex combinations like a hotel with a rent-a-car or a skipass or ski lessons, packages
 * should be used so that each service can be described properly and a choice of what car,
 * which ski pass and what level of ski class that be properly selected.
 * 
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/service_fact.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/service_fact.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.ServiceFact
 */
export class ServiceFact extends Message<ServiceFact> {
  /**
   * A code for the specific service, when a service is optional, this code is
   * referenced in the validate request, so that the optional service will be added
   * to the booking.
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * the price and price breakdown of the service
   *
   * @generated from field: cmp.types.v4.PriceDetail price_detail = 3;
   */
  priceDetail?: PriceDetail;

  /**
   * whether the service is included, optional or compulsory. When a price is
   * mentioned and the service is included, then the price of the service is already
   * included in the total price of this option and it is better to omit the
   * price_detail field. In case of an optional or compulsory service, the service
   * must be specifically be booked and the price is added to the total price.
   *
   * @generated from field: cmp.types.v4.ServiceAvailabilityType availability_type = 4;
   */
  availabilityType = ServiceAvailabilityType.UNSPECIFIED;

  /**
   * The ChargeBasisType specifies whether this service is only charged once for the
   * whole booking, for each participant, for each room or flight etc, for each day
   * or for a combination of these concepts like for example "foreign distilleries
   * per participant per day" or just once in case of a massage, but you would be
   * able to order 3 of them in the booking.
   *
   * @generated from field: cmp.types.v4.ChargeBasisType charge_basis = 5;
   */
  chargeBasis = ChargeBasisType.UNSPECIFIED;

  /**
   * We can use a single ServiceFact to express just one service.
   * But services can actually be a combination of several services, like
   * priority boarding, which also allows for an optional larger carry-on bag.
   * 
   * IMPORTANT: Please be careful about this recursion as only a handful of cases
   * are well-known combinations of different service availability types.
   * Distributors might only implement on their end a very limited set of combinations,
   * therefore it would be better to clarify first what the commonly used ones
   * are before trying to express business cases which are simply not supported.
   *
   * @generated from field: repeated cmp.types.v4.ServiceFact details = 6;
   */
  details: ServiceFact[] = [];

  /**
   * The count of the number of services. In case the service requires specification
   * of the number or frequency of the products that will be included. For example
   * "bouquet of roses, qty=24" or "baggage qty=2".
   *
   * @generated from field: uint32 quantity = 7;
   */
  quantity = 0;

  constructor(data?: PartialMessage<ServiceFact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ServiceFact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price_detail", kind: "message", T: PriceDetail },
    { no: 4, name: "availability_type", kind: "enum", T: proto3.getEnumType(ServiceAvailabilityType) },
    { no: 5, name: "charge_basis", kind: "enum", T: proto3.getEnumType(ChargeBasisType) },
    { no: 6, name: "details", kind: "message", T: ServiceFact, repeated: true },
    { no: 7, name: "quantity", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceFact {
    return new ServiceFact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceFact {
    return new ServiceFact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceFact {
    return new ServiceFact().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceFact | PlainMessage<ServiceFact> | undefined, b: ServiceFact | PlainMessage<ServiceFact> | undefined): boolean {
    return proto3.util.equals(ServiceFact, a, b);
  }
}

/**
 * Static data definition of the service fact to be used in product information
 *
 * @generated from message cmp.types.v4.ServiceFactDefinition
 */
export class ServiceFactDefinition extends Message<ServiceFactDefinition> {
  /**
   * A code for the specific service, when a service is optional, this code is
   * referenced in the validate request, so that the optional service will be added
   * to the booking.
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * A description of the service like "business class", "shuttle transfer", "early
   * check-in" etc.
   *
   * @generated from field: repeated cmp.types.v4.LocalizedString description = 2;
   */
  description: LocalizedString[] = [];

  constructor(data?: PartialMessage<ServiceFactDefinition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ServiceFactDefinition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: LocalizedString, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServiceFactDefinition {
    return new ServiceFactDefinition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServiceFactDefinition {
    return new ServiceFactDefinition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServiceFactDefinition {
    return new ServiceFactDefinition().fromJsonString(jsonString, options);
  }

  static equals(a: ServiceFactDefinition | PlainMessage<ServiceFactDefinition> | undefined, b: ServiceFactDefinition | PlainMessage<ServiceFactDefinition> | undefined): boolean {
    return proto3.util.equals(ServiceFactDefinition, a, b);
  }
}

