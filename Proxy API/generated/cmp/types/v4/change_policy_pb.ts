// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/change_policy.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { DateTimeRange } from "./datetime_range_pb";
import { Price } from "./price_pb";

/**
 * Change Policy: The change policy section consists of 2 different
 * ways to express change policies:
 * - A simple "free change upto" structure (essentially only a timestamp)
 * - Complex change policies with from/to DateTime stamps, individual prices
 *   and rateplan applicability
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/change_policy.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/change_policy.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.ChangePolicy
 */
export class ChangePolicy extends Message<ChangePolicy> {
  /**
   * @generated from oneof cmp.types.v4.ChangePolicy.policy_type
   */
  policyType: {
    /**
     * The "free change upto" identifier specifies the exact DateTime upto when
     * this search result can be changed free of charge.
     * 
     * Timestamps may be used for both off-chain and on-chain operations.
     * For on-chain operations, only seconds are supported, and nanoseconds
     * will be ignored.
     *
     * @generated from field: google.protobuf.Timestamp free_change_upto = 2;
     */
    value: Timestamp;
    case: "freeChangeUpto";
  } | {
    /**
     * Complex change types - see ComplexChangeTypes message for details
     *
     * @generated from field: cmp.types.v4.ComplexChangeTypes complex_change_types = 3;
     */
    value: ComplexChangeTypes;
    case: "complexChangeTypes";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ChangePolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ChangePolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "free_change_upto", kind: "message", T: Timestamp, oneof: "policy_type" },
    { no: 3, name: "complex_change_types", kind: "message", T: ComplexChangeTypes, oneof: "policy_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangePolicy {
    return new ChangePolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangePolicy {
    return new ChangePolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangePolicy {
    return new ChangePolicy().fromJsonString(jsonString, options);
  }

  static equals(a: ChangePolicy | PlainMessage<ChangePolicy> | undefined, b: ChangePolicy | PlainMessage<ChangePolicy> | undefined): boolean {
    return proto3.util.equals(ChangePolicy, a, b);
  }
}

/**
 * @generated from message cmp.types.v4.ComplexChangeTypes
 */
export class ComplexChangeTypes extends Message<ComplexChangeTypes> {
  /**
   * Specify several change types with their fees relative to the start
   * date-time of the service. When in the inventory system several entries with
   * different hours before specified, like for example 10€ from 240 hours (10 days)
   * before consumption, 50€ from 5 days before consumption and 100€ from 24 hours
   * before consumption, they must be computed to one uniform format of date ranges
   * and fees, related to the start DateTime of the service or product
   * delivery.
   *
   * @generated from field: repeated cmp.types.v4.ChangeType change_types = 1;
   */
  changeTypes: ChangeType[] = [];

  constructor(data?: PartialMessage<ComplexChangeTypes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ComplexChangeTypes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "change_types", kind: "message", T: ChangeType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexChangeTypes {
    return new ComplexChangeTypes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexChangeTypes {
    return new ComplexChangeTypes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexChangeTypes {
    return new ComplexChangeTypes().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexChangeTypes | PlainMessage<ComplexChangeTypes> | undefined, b: ComplexChangeTypes | PlainMessage<ComplexChangeTypes> | undefined): boolean {
    return proto3.util.equals(ComplexChangeTypes, a, b);
  }
}

/**
 * ChangeTypes Different change types can be defined depending on what part of a
 * travel booking requires to be changed (like for example the common "name change",
 * "date change" or the change of a service booked to another service). Each of these
 * changes can be possible or not in relation to the time until the service is
 * delivered or the cost of the change may vary closer to the delivery of the
 * service.
 *
 * @generated from message cmp.types.v4.ChangeType
 */
export class ChangeType extends Message<ChangeType> {
  /**
   * Change type code in case the change type has a specific code
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * When this change type and date is valid. Either use the start and end date of
   * the DateTime range
   *
   * @generated from field: cmp.types.v4.DateTimeRange datetime_range = 2;
   */
  datetimeRange?: DateTimeRange;

  /**
   * change fee. Percentages of the selling price are purposely not allowed for
   * simplicity and uniformity.
   *
   * @generated from field: cmp.types.v4.Price value = 3;
   */
  value?: Price;

  /**
   * Description of the change in a non computable manner. The Description should be
   * in the language that is specified in the request.
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * For which rateplan the policy is valid.
   *
   * @generated from field: repeated string valid_for_rate_plans = 5;
   */
  validForRatePlans: string[] = [];

  constructor(data?: PartialMessage<ChangeType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ChangeType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "datetime_range", kind: "message", T: DateTimeRange },
    { no: 3, name: "value", kind: "message", T: Price },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "valid_for_rate_plans", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeType {
    return new ChangeType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeType {
    return new ChangeType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeType {
    return new ChangeType().fromJsonString(jsonString, options);
  }

  static equals(a: ChangeType | PlainMessage<ChangeType> | undefined, b: ChangeType | PlainMessage<ChangeType> | undefined): boolean {
    return proto3.util.equals(ChangeType, a, b);
  }
}

