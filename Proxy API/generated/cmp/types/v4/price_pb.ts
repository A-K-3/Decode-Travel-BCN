// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/price.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ChargeType, PriceBreakdownType } from "./price_types_pb";
import { Currency } from "./currency_pb";

/**
 * This message consists of the value as a Price object and additional fields as
 * binding, concept, and breakdown.
 * 
 * Breakdown is a recursively inherited object of PriceDetail. This way complex
 * pricing structures can be represented.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/price.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/price.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.PriceDetail
 */
export class PriceDetail extends Message<PriceDetail> {
  /**
   * Principle price element
   *
   * @generated from field: cmp.types.v4.Price price = 1;
   */
  price?: Price;

  /**
   * The ChargeType defines whether a price is per person, per group or per unit.
   *
   * @generated from field: cmp.types.v4.ChargeType charge_type = 2;
   */
  chargeType = ChargeType.UNSPECIFIED;

  /**
   * Identification whether the price must be respected towards the end-user
   * and the product or service cannot be offered for a lower price.
   *
   * @generated from field: bool binding = 3;
   */
  binding = false;

  /**
   * Description of the product or service this price(element) is valid for.
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * If not specified, the default of the boolean is false which means it is
   * included in the price. If set to True, it means that this PriceDetail is only
   * payable locally. For example local tourism tax that you pay at the reception of
   * a hotel. Intended to be used in the breakdown.
   *
   * @generated from field: bool locally_payable = 5;
   */
  locallyPayable = false;

  /**
   * Type of price breakdown. This is meant to be used in price breakdown
   * definitions, when we want to specify the different elements of how a total
   * price was computed.
   *
   * @generated from field: cmp.types.v4.PriceBreakdownType type = 6;
   */
  type?: PriceBreakdownType;

  /**
   * We can use a single PriceDetail to represent a price breakdown.
   *
   * @generated from field: repeated cmp.types.v4.PriceDetail breakdowns = 7;
   */
  breakdowns: PriceDetail[] = [];

  constructor(data?: PartialMessage<PriceDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.PriceDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "message", T: Price },
    { no: 2, name: "charge_type", kind: "enum", T: proto3.getEnumType(ChargeType) },
    { no: 3, name: "binding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "locally_payable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "type", kind: "message", T: PriceBreakdownType },
    { no: 7, name: "breakdowns", kind: "message", T: PriceDetail, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceDetail {
    return new PriceDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJsonString(jsonString, options);
  }

  static equals(a: PriceDetail | PlainMessage<PriceDetail> | undefined, b: PriceDetail | PlainMessage<PriceDetail> | undefined): boolean {
    return proto3.util.equals(PriceDetail, a, b);
  }
}

/**
 * Represents a monetary value with arbitrary precision using a string-based integer
 * representation. This design supports both traditional fiat currencies and
 * cryptocurrencies that may require high precision decimal handling.
 * 
 * The price is expressed as: actual_value = value / 10^decimals
 * 
 * ## Key Principles
 * 
 * 1. **Always represent the main currency unit**, not fractions:
 *    - Use EUR (not euro-cents), BTC (not satoshis), ETH (not wei)
 *    - Example: €1.23 is stored as value="123", decimals=2
 * 
 * 2. **String-based value prevents precision loss**:
 *    - Essential for cryptocurrencies with 18+ decimal places
 *    - Avoids floating-point rounding errors
 *    - Supports values up to uint256 range
 * 
 * 3. **Flexible decimal precision**:
 *    - Accommodates different currency requirements
 *    - Fiat currencies typically use 2 decimals
 *    - Cryptocurrencies may use 6-18 decimals
 * 
 * ## Implementation Examples
 * 
 * ### Fiat Currency
 * ```
 * €100.50 → value="10050", decimals=2
 * $0.99 → value="99", decimals=2
 * ```
 * 
 * ### Cryptocurrency Display
 * ```
 * 0.0065 BTC → value="65", decimals=4 (for UI display)
 * 1.5 ETH → value="15", decimals=1
 * ```
 * 
 * ### Blockchain Operations
 * For on-chain transactions, convert to the blockchain's native precision:
 * ```
 * Display: 0.0065 WBTC (value="65", decimals=4)
 * On-chain: 650000 (multiply by 10^(8-4) for 8-decimal blockchain)
 * ```
 * 
 * ## Important Notes
 * 
 * - Never round cryptocurrency values - use exact decimal arithmetic
 * - The decimals field specifies how many decimal places are represented
 * - For blockchain operations, additional conversion may be needed to match
 *   the on-chain decimal precision
 *
 * @generated from message cmp.types.v4.Price
 */
export class Price extends Message<Price> {
  /**
   * The price value as a string representation of an integer.
   * To get the actual value: actual_value = value / 10^decimals
   * Example: value="12345" with decimals=2 represents 123.45
   *
   * @generated from field: string value = 1;
   */
  value = "";

  /**
   * Number of decimal places represented in the value.
   * Example: decimals=2 means the value should be divided by 100
   *
   * @generated from field: uint32 decimals = 2;
   */
  decimals = 0;

  /**
   * The currency specification (fiat or cryptocurrency)
   *
   * @generated from field: cmp.types.v4.Currency currency = 3;
   */
  currency?: Currency;

  constructor(data?: PartialMessage<Price>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Price";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "currency", kind: "message", T: Currency },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Price {
    return new Price().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJsonString(jsonString, options);
  }

  static equals(a: Price | PlainMessage<Price> | undefined, b: Price | PlainMessage<Price> | undefined): boolean {
    return proto3.util.equals(Price, a, b);
  }
}

