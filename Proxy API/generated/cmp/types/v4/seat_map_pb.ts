// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/seat_map.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Int32Value, Message, proto3 } from "@bufbuild/protobuf";
import { LocalizedString } from "./localized_pb";
import { Image } from "./file_pb";
import { DateTimeRange } from "./datetime_range_pb";

/**
 * @generated from enum cmp.types.v4.SeatAttributeType
 */
export enum SeatAttributeType {
  /**
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Seat is located next to a window
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_WINDOW_SEAT = 1;
   */
  WINDOW_SEAT = 1,

  /**
   * Seat is located next to the aisle for easy access
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_AISLE_SEAT = 2;
   */
  AISLE_SEAT = 2,

  /**
   * Seat is located in an emergency exit row (may have restrictions)
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_EXIT_ROW = 3;
   */
  EXIT_ROW = 3,

  /**
   * Seat is accessible for wheelchair users
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_WHEELCHAIR_ACCESSIBLE = 4;
   */
  WHEELCHAIR_ACCESSIBLE = 4,

  /**
   * Seat has additional legroom space
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_EXTRA_LEGROOM = 5;
   */
  EXTRA_LEGROOM = 5,

  /**
   * Seat has limited or no recline capability
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_LIMITED_RECLINE = 6;
   */
  LIMITED_RECLINE = 6,

  /**
   * Seat has a restricted or obstructed view
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_RESTRICTED_VIEW = 7;
   */
  RESTRICTED_VIEW = 7,

  /**
   * Seat has an electrical power outlet available
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_POWER_OUTLET = 8;
   */
  POWER_OUTLET = 8,

  /**
   * Seat has a table or tray table
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_TABLE = 9;
   */
  TABLE = 9,

  /**
   * Seat has an entertainment screen
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_SCREEN = 10;
   */
  SCREEN = 10,

  /**
   * Seat has storage compartments
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_STORAGE = 11;
   */
  STORAGE = 11,

  /**
   * Seat has individual climate control (air vents, heating)
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_CLIMATE_CONTROL = 12;
   */
  CLIMATE_CONTROL = 12,

  /**
   * Seat has dedicated armrests
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_ARMREST = 13;
   */
  ARMREST = 13,

  /**
   * Seat shares armrests with adjacent seats
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_SHARED_ARMREST = 14;
   */
  SHARED_ARMREST = 14,

  /**
   * Seat is designated as VIP or premium seating
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_VIP_SEATING = 15;
   */
  VIP_SEATING = 15,

  /**
   * Seat is located near the performance stage or focal point
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_NEAR_STAGE = 16;
   */
  NEAR_STAGE = 16,

  /**
   * Seat is located near a bar or beverage service area
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_NEAR_BAR = 17;
   */
  NEAR_BAR = 17,

  /**
   * Seat is located near restroom facilities
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_NEAR_RESTROOM = 18;
   */
  NEAR_RESTROOM = 18,

  /**
   * Seat is located near galley or kitchen area (aviation/transport)
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_NEAR_GALLEY = 19;
   */
  NEAR_GALLEY = 19,

  /**
   * Seat is located near emergency exit points
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_NEAR_EMERGENCY_EXIT = 20;
   */
  NEAR_EMERGENCY_EXIT = 20,

  /**
   * Seat has an age requirement
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_AGE = 21;
   */
  AGE = 21,

  /**
   * Seat has a weight restriction for occupancy
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_WEIGHT = 22;
   */
  WEIGHT = 22,

  /**
   * Seat has a height restriction for occupancy
   *
   * @generated from enum value: SEAT_ATTRIBUTE_TYPE_HEIGHT = 23;
   */
  HEIGHT = 23,
}
// Retrieve enum metadata with: proto3.getEnumType(SeatAttributeType)
proto3.util.setEnumType(SeatAttributeType, "cmp.types.v4.SeatAttributeType", [
  { no: 0, name: "SEAT_ATTRIBUTE_TYPE_UNSPECIFIED" },
  { no: 1, name: "SEAT_ATTRIBUTE_TYPE_WINDOW_SEAT" },
  { no: 2, name: "SEAT_ATTRIBUTE_TYPE_AISLE_SEAT" },
  { no: 3, name: "SEAT_ATTRIBUTE_TYPE_EXIT_ROW" },
  { no: 4, name: "SEAT_ATTRIBUTE_TYPE_WHEELCHAIR_ACCESSIBLE" },
  { no: 5, name: "SEAT_ATTRIBUTE_TYPE_EXTRA_LEGROOM" },
  { no: 6, name: "SEAT_ATTRIBUTE_TYPE_LIMITED_RECLINE" },
  { no: 7, name: "SEAT_ATTRIBUTE_TYPE_RESTRICTED_VIEW" },
  { no: 8, name: "SEAT_ATTRIBUTE_TYPE_POWER_OUTLET" },
  { no: 9, name: "SEAT_ATTRIBUTE_TYPE_TABLE" },
  { no: 10, name: "SEAT_ATTRIBUTE_TYPE_SCREEN" },
  { no: 11, name: "SEAT_ATTRIBUTE_TYPE_STORAGE" },
  { no: 12, name: "SEAT_ATTRIBUTE_TYPE_CLIMATE_CONTROL" },
  { no: 13, name: "SEAT_ATTRIBUTE_TYPE_ARMREST" },
  { no: 14, name: "SEAT_ATTRIBUTE_TYPE_SHARED_ARMREST" },
  { no: 15, name: "SEAT_ATTRIBUTE_TYPE_VIP_SEATING" },
  { no: 16, name: "SEAT_ATTRIBUTE_TYPE_NEAR_STAGE" },
  { no: 17, name: "SEAT_ATTRIBUTE_TYPE_NEAR_BAR" },
  { no: 18, name: "SEAT_ATTRIBUTE_TYPE_NEAR_RESTROOM" },
  { no: 19, name: "SEAT_ATTRIBUTE_TYPE_NEAR_GALLEY" },
  { no: 20, name: "SEAT_ATTRIBUTE_TYPE_NEAR_EMERGENCY_EXIT" },
  { no: 21, name: "SEAT_ATTRIBUTE_TYPE_AGE" },
  { no: 22, name: "SEAT_ATTRIBUTE_TYPE_WEIGHT" },
  { no: 23, name: "SEAT_ATTRIBUTE_TYPE_HEIGHT" },
]);

/**
 * @generated from enum cmp.types.v4.SeatAttributeValueType
 */
export enum SeatAttributeValueType {
  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_DISTANCE = 1;
   */
  DISTANCE = 1,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MAX_ANGLE = 2;
   */
  MAX_ANGLE = 2,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MIN_AGE = 3;
   */
  MIN_AGE = 3,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MAX_AGE = 4;
   */
  MAX_AGE = 4,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MIN_HEIGHT = 5;
   */
  MIN_HEIGHT = 5,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MAX_HEIGHT = 6;
   */
  MAX_HEIGHT = 6,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_MAX_WEIGHT = 7;
   */
  MAX_WEIGHT = 7,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_ADDITIONAL_CHARGE = 8;
   */
  ADDITIONAL_CHARGE = 8,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_VALUE_TYPE_COUNT = 9;
   */
  COUNT = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(SeatAttributeValueType)
proto3.util.setEnumType(SeatAttributeValueType, "cmp.types.v4.SeatAttributeValueType", [
  { no: 0, name: "SEAT_ATTRIBUTE_VALUE_TYPE_UNSPECIFIED" },
  { no: 1, name: "SEAT_ATTRIBUTE_VALUE_TYPE_DISTANCE" },
  { no: 2, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MAX_ANGLE" },
  { no: 3, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MIN_AGE" },
  { no: 4, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MAX_AGE" },
  { no: 5, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MIN_HEIGHT" },
  { no: 6, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MAX_HEIGHT" },
  { no: 7, name: "SEAT_ATTRIBUTE_VALUE_TYPE_MAX_WEIGHT" },
  { no: 8, name: "SEAT_ATTRIBUTE_VALUE_TYPE_ADDITIONAL_CHARGE" },
  { no: 9, name: "SEAT_ATTRIBUTE_VALUE_TYPE_COUNT" },
]);

/**
 * @generated from enum cmp.types.v4.SeatAttributeUnit
 */
export enum SeatAttributeUnit {
  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_CENTIMETER = 1;
   */
  CENTIMETER = 1,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_INCH = 2;
   */
  INCH = 2,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_METER = 3;
   */
  METER = 3,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_FOOT = 4;
   */
  FOOT = 4,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_KILOMETER = 5;
   */
  KILOMETER = 5,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_MILES = 6;
   */
  MILES = 6,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_KILOGRAM = 7;
   */
  KILOGRAM = 7,

  /**
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_POUND = 8;
   */
  POUND = 8,

  /**
   * The currency used for the booking
   *
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_BOOKING_CURRENCY = 9;
   */
  BOOKING_CURRENCY = 9,

  /**
   * The local currency of the property's location
   *
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_LOCAL_CURRENCY = 10;
   */
  LOCAL_CURRENCY = 10,

  /**
   * Unit for angles (e.g., seat recline angle)
   *
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_DEGREE = 11;
   */
  DEGREE = 11,

  /**
   * Unit for age-related attributes
   *
   * @generated from enum value: SEAT_ATTRIBUTE_UNIT_YEARS = 12;
   */
  YEARS = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(SeatAttributeUnit)
proto3.util.setEnumType(SeatAttributeUnit, "cmp.types.v4.SeatAttributeUnit", [
  { no: 0, name: "SEAT_ATTRIBUTE_UNIT_UNSPECIFIED" },
  { no: 1, name: "SEAT_ATTRIBUTE_UNIT_CENTIMETER" },
  { no: 2, name: "SEAT_ATTRIBUTE_UNIT_INCH" },
  { no: 3, name: "SEAT_ATTRIBUTE_UNIT_METER" },
  { no: 4, name: "SEAT_ATTRIBUTE_UNIT_FOOT" },
  { no: 5, name: "SEAT_ATTRIBUTE_UNIT_KILOMETER" },
  { no: 6, name: "SEAT_ATTRIBUTE_UNIT_MILES" },
  { no: 7, name: "SEAT_ATTRIBUTE_UNIT_KILOGRAM" },
  { no: 8, name: "SEAT_ATTRIBUTE_UNIT_POUND" },
  { no: 9, name: "SEAT_ATTRIBUTE_UNIT_BOOKING_CURRENCY" },
  { no: 10, name: "SEAT_ATTRIBUTE_UNIT_LOCAL_CURRENCY" },
  { no: 11, name: "SEAT_ATTRIBUTE_UNIT_DEGREE" },
  { no: 12, name: "SEAT_ATTRIBUTE_UNIT_YEARS" },
]);

/**
 * Enumerates the geometric shapes used to define clickable regions for seats
 * in a bitmap image seat map (see `BitmapSeatLocation`).
 * These types generally correspond to the `shape` attribute of an HTML `<area>` tag.
 *
 * @generated from enum cmp.types.v4.AreaType
 */
export enum AreaType {
  /**
   * Default, should not be used (enforced by validation).
   *
   * @generated from enum value: AREA_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A rectangular area.
   *
   * @generated from enum value: AREA_TYPE_RECTANGLE = 1;
   */
  RECTANGLE = 1,

  /**
   * A circular area.
   *
   * @generated from enum value: AREA_TYPE_CIRCLE = 2;
   */
  CIRCLE = 2,

  /**
   * A polygonal area (defined by a set of vertices).
   *
   * @generated from enum value: AREA_TYPE_POLYGON = 3;
   */
  POLYGON = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AreaType)
proto3.util.setEnumType(AreaType, "cmp.types.v4.AreaType", [
  { no: 0, name: "AREA_TYPE_UNSPECIFIED" },
  { no: 1, name: "AREA_TYPE_RECTANGLE" },
  { no: 2, name: "AREA_TYPE_CIRCLE" },
  { no: 3, name: "AREA_TYPE_POLYGON" },
]);

/**
 * Unique identifier for the seat map.
 * This ID is used to reference the seat map in requests and responses.
 *
 * @generated from message cmp.types.v4.SeatMapID
 */
export class SeatMapID extends Message<SeatMapID> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<SeatMapID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatMapID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapID {
    return new SeatMapID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapID {
    return new SeatMapID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapID {
    return new SeatMapID().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapID | PlainMessage<SeatMapID> | undefined, b: SeatMapID | PlainMessage<SeatMapID> | undefined): boolean {
    return proto3.util.equals(SeatMapID, a, b);
  }
}

/**
 * Represents a basic seat with attributes. Each seat has a
 * unique identifier and a location within a visual seat map (if provided for its
 * section). It can also have various attributes like features and restrictions.
 *
 * @generated from message cmp.types.v4.Seat
 */
export class Seat extends Message<Seat> {
  /**
   * Unique identifier for the seat within its section (e.g., "12B", "A26").
   * This identifier, in conjunction with its parent section(s) IDs, forms a
   * globally unique seat reference within the seat map.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The location of the seat within a visual seat map image
   * (e.g., an SVG or bitmap image defined in the parent `Section`).
   * This is used if the section provides an `image` for seat selection.
   *
   * @generated from field: cmp.types.v4.SeatLocation location = 2;
   */
  location?: SeatLocation;

  /**
   * Individual seat attribute definition. Only use this for special seats
   * inside of a section. If there are attributes which apply to all seats
   * of a section please use the section attributes instead to save bandwidth.
   *
   * @generated from field: repeated cmp.types.v4.SeatAttribute attributes = 3;
   */
  attributes: SeatAttribute[] = [];

  constructor(data?: PartialMessage<Seat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Seat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "location", kind: "message", T: SeatLocation },
    { no: 3, name: "attributes", kind: "message", T: SeatAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Seat {
    return new Seat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Seat {
    return new Seat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Seat {
    return new Seat().fromJsonString(jsonString, options);
  }

  static equals(a: Seat | PlainMessage<Seat> | undefined, b: Seat | PlainMessage<Seat> | undefined): boolean {
    return proto3.util.equals(Seat, a, b);
  }
}

/**
 * Represents a list of individual seats, typically within a section.
 *
 * @generated from message cmp.types.v4.SeatList
 */
export class SeatList extends Message<SeatList> {
  /**
   * A collection of seats. Must contain at least one seat if `SeatList` is used.
   *
   * @generated from field: repeated cmp.types.v4.Seat seats = 1;
   */
  seats: Seat[] = [];

  constructor(data?: PartialMessage<SeatList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seats", kind: "message", T: Seat, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatList {
    return new SeatList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatList {
    return new SeatList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatList {
    return new SeatList().fromJsonString(jsonString, options);
  }

  static equals(a: SeatList | PlainMessage<SeatList> | undefined, b: SeatList | PlainMessage<SeatList> | undefined): boolean {
    return proto3.util.equals(SeatList, a, b);
  }
}

/**
 * Nested sub-sections within a section, allowing for a
 * hierarchical layout (e.g., a "Balcony" section might contain "Row-A",
 * "Row-B" sub-sections).
 *
 * @generated from message cmp.types.v4.SubSections
 */
export class SubSections extends Message<SubSections> {
  /**
   * @generated from field: repeated cmp.types.v4.Section sections = 1;
   */
  sections: Section[] = [];

  constructor(data?: PartialMessage<SubSections>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SubSections";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sections", kind: "message", T: Section, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubSections {
    return new SubSections().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubSections {
    return new SubSections().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubSections {
    return new SubSections().fromJsonString(jsonString, options);
  }

  static equals(a: SubSections | PlainMessage<SubSections> | undefined, b: SubSections | PlainMessage<SubSections> | undefined): boolean {
    return proto3.util.equals(SubSections, a, b);
  }
}

/**
 * A Section represents a distinct, named area within a venue's seat map.
 * Examples: a block of rows in a theater, a specific standing area, a seating
 * tier in a stadium, or a cabin class in an airplane. Sections can be nested
 * to create a hierarchical layout.
 *
 * @generated from message cmp.types.v4.Section
 */
export class Section extends Message<Section> {
  /**
   * Unique identifier for this section (e.g., "UpperDeck", "Balcony-Left",
   * "Section-101", "Orchestra-Row-A"). This ID should be unique within its
   * parent section or globally within the `SeatMap` if it's a top-level section.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * List of localized human-readable names for the section
   * (e.g., "Balcony", "Orchestra", "First Class", "Business Class").
   *
   * @generated from field: repeated cmp.types.v4.LocalizedString names = 2;
   */
  names: LocalizedString[] = [];

  /**
   * Defines how seat information for this section is provided: either as a
   * detailed list of individual seats or as a total count (for general
   * admission areas). One of these must be provided.
   *
   * @generated from oneof cmp.types.v4.Section.seat_info
   */
  seatInfo: {
    /**
     * A detailed list of individual seats within this section.
     * Use this for reserved seating areas where each seat has an identifier.
     *
     * @generated from field: cmp.types.v4.SeatList seat_list = 3;
     */
    value: SeatList;
    case: "seatList";
  } | {
    /**
     * The total number of allocatable spots or "seats" in this section.
     * Use this for general admission areas (e.g., standing room, unassigned
     * seating) where individual seat details are not applicable.
     *
     * @generated from field: google.protobuf.Int32Value seat_count = 4;
     */
    value: Int32Value;
    case: "seatCount";
  } | {
    /**
     * Subsection to allow hierarchical section definitions.
     *
     * @generated from field: cmp.types.v4.SubSections subsections = 5;
     */
    value: SubSections;
    case: "subsections";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A visual representation (SVG or bitmap) of this section's layout.
   * If provided, `Seat.location` for seats within this section will refer to
   * coordinates or labels within this image.
   *
   * @generated from field: cmp.types.v4.Image image = 6;
   */
  image?: Image;

  /**
   * SeatAttributes which apply to all seats within this section. And also to
   * all seats in nested sub-sections.
   *
   * @generated from field: repeated cmp.types.v4.SeatAttribute attributes = 7;
   */
  attributes: SeatAttribute[] = [];

  constructor(data?: PartialMessage<Section>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Section";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "names", kind: "message", T: LocalizedString, repeated: true },
    { no: 3, name: "seat_list", kind: "message", T: SeatList, oneof: "seat_info" },
    { no: 4, name: "seat_count", kind: "message", T: Int32Value, oneof: "seat_info" },
    { no: 5, name: "subsections", kind: "message", T: SubSections, oneof: "seat_info" },
    { no: 6, name: "image", kind: "message", T: Image },
    { no: 7, name: "attributes", kind: "message", T: SeatAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Section {
    return new Section().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Section {
    return new Section().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Section {
    return new Section().fromJsonString(jsonString, options);
  }

  static equals(a: Section | PlainMessage<Section> | undefined, b: Section | PlainMessage<Section> | undefined): boolean {
    return proto3.util.equals(Section, a, b);
  }
}

/**
 * Representation of a seat map structure, defining the layout and structure
 * of seating within a venue or transportation. It is defined by creating sections
 * and can have an image to be referenced by sections and seats, as well as
 * localized descriptions.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/seat_map.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/seat_map.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.SeatMap
 */
export class SeatMap extends Message<SeatMap> {
  /**
   * Unique identifier for this entire seat map (e.g., "venueName-standardLayout").
   *
   * @generated from field: cmp.types.v4.SeatMapID id = 1;
   */
  id?: SeatMapID;

  /**
   * A list of top-level sections within the seat map. Sections can be nested.
   *
   * @generated from field: repeated cmp.types.v4.Section sections = 2;
   */
  sections: Section[] = [];

  /**
   * An image providing an overall visual representation of the entire
   * seat map layout. This might be a venue overview an airplane or anything
   * else which has a seating arrangement.
   *
   * @generated from field: cmp.types.v4.Image image = 3;
   */
  image?: Image;

  /**
   * Attributes which apply to all seats within the entire seat map.
   * These might describe general venue features or seating policies.
   *
   * @generated from field: repeated cmp.types.v4.SeatAttribute attributes = 4;
   */
  attributes: SeatAttribute[] = [];

  constructor(data?: PartialMessage<SeatMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: SeatMapID },
    { no: 2, name: "sections", kind: "message", T: Section, repeated: true },
    { no: 3, name: "image", kind: "message", T: Image },
    { no: 4, name: "attributes", kind: "message", T: SeatAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMap {
    return new SeatMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMap {
    return new SeatMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMap {
    return new SeatMap().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMap | PlainMessage<SeatMap> | undefined, b: SeatMap | PlainMessage<SeatMap> | undefined): boolean {
    return proto3.util.equals(SeatMap, a, b);
  }
}

/**
 * Represents a collection of seat identifiers, used for specifying
 * selected seats or checking availability of specific seats.
 *
 * @generated from message cmp.types.v4.SeatInventory
 */
export class SeatInventory extends Message<SeatInventory> {
  /**
   * A list of unique seat identifiers. Must contain at least one ID.
   * Each ID corresponds to a `Seat.id` within a specific section.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<SeatInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatInventory {
    return new SeatInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatInventory {
    return new SeatInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatInventory {
    return new SeatInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SeatInventory | PlainMessage<SeatInventory> | undefined, b: SeatInventory | PlainMessage<SeatInventory> | undefined): boolean {
    return proto3.util.equals(SeatInventory, a, b);
  }
}

/**
 * Nested sub-sections within a section, allowing for a
 * hierarchical representation of seat inventory.
 *
 * @generated from message cmp.types.v4.SubSectionsInventory
 */
export class SubSectionsInventory extends Message<SubSectionsInventory> {
  /**
   * @generated from field: repeated cmp.types.v4.SectionInventory sections = 1;
   */
  sections: SectionInventory[] = [];

  constructor(data?: PartialMessage<SubSectionsInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SubSectionsInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sections", kind: "message", T: SectionInventory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubSectionsInventory {
    return new SubSectionsInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubSectionsInventory {
    return new SubSectionsInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubSectionsInventory {
    return new SubSectionsInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SubSectionsInventory | PlainMessage<SubSectionsInventory> | undefined, b: SubSectionsInventory | PlainMessage<SubSectionsInventory> | undefined): boolean {
    return proto3.util.equals(SubSectionsInventory, a, b);
  }
}

/**
 * Represents the inventory status (e.g., available, selected) for a specific
 * section and its potential sub-sections. This is used for dynamic data like
 * seat availability or seat selections.
 *
 * @generated from message cmp.types.v4.SectionInventory
 */
export class SectionInventory extends Message<SectionInventory> {
  /**
   * Unique identifier of the section this inventory pertains to.
   * This must match a `Section.id` from the corresponding `SeatMap`.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Defines how seat inventory information for this section is provided.
   *
   * @generated from oneof cmp.types.v4.SectionInventory.seat_info
   */
  seatInfo: {
    /**
     * A list of specific seat IDs within this section that are part of this
     * inventory (e.g., available seats, selected seats).
     *
     * @generated from field: cmp.types.v4.SeatInventory seat_list = 2;
     */
    value: SeatInventory;
    case: "seatList";
  } | {
    /**
     * The number of seats/spots in this section that are part of this inventory.
     * Used for general admission sections where individual seats are not tracked.
     * Represents, for example, remaining available spots or number of selected GA tickets.
     *
     * @generated from field: google.protobuf.Int32Value seat_count = 3;
     */
    value: Int32Value;
    case: "seatCount";
  } | {
    /**
     * Sub-section inventory to allow hierarchical section inventory definitions.
     *
     * @generated from field: cmp.types.v4.SubSectionsInventory subsections = 4;
     */
    value: SubSectionsInventory;
    case: "subsections";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SectionInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SectionInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "seat_list", kind: "message", T: SeatInventory, oneof: "seat_info" },
    { no: 3, name: "seat_count", kind: "message", T: Int32Value, oneof: "seat_info" },
    { no: 4, name: "subsections", kind: "message", T: SubSectionsInventory, oneof: "seat_info" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SectionInventory {
    return new SectionInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SectionInventory {
    return new SectionInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SectionInventory {
    return new SectionInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SectionInventory | PlainMessage<SectionInventory> | undefined, b: SectionInventory | PlainMessage<SectionInventory> | undefined): boolean {
    return proto3.util.equals(SectionInventory, a, b);
  }
}

/**
 * Represents the inventory status or seat selection for a specific seat map.
 * This message aggregates inventory information for all relevant sections,
 * used for purposes like seat selection or displaying seat availability.
 *
 * @generated from message cmp.types.v4.SeatMapInventory
 */
export class SeatMapInventory extends Message<SeatMapInventory> {
  /**
   * Unique identifier of the `SeatMap` this inventory refers to.
   *
   * @generated from field: cmp.types.v4.SeatMapID id = 1;
   */
  id?: SeatMapID;

  /**
   * A list of inventory details for the top-level sections within the seat map.
   *
   * @generated from field: repeated cmp.types.v4.SectionInventory sections = 2;
   */
  sections: SectionInventory[] = [];

  constructor(data?: PartialMessage<SeatMapInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatMapInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: SeatMapID },
    { no: 2, name: "sections", kind: "message", T: SectionInventory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapInventory | PlainMessage<SeatMapInventory> | undefined, b: SeatMapInventory | PlainMessage<SeatMapInventory> | undefined): boolean {
    return proto3.util.equals(SeatMapInventory, a, b);
  }
}

/**
 * Represents an attribute of a seat (feature or restriction).
 * Examples:
 * - "WINDOW_SEAT"
 * - "EXTRA_LEGROOM" (optional with associated value to specify how much extra legroom)
 * - "LIMITED_RECLINE" (optional with associated value to specify max recline angle)
 * - "WHEELCHAIR_ACCESSIBLE": When it's for example wheelchair accessible
 * - "AGE": When there's a minimum age requirement to occupy the seat
 * - "WEIGHT": When there's a weight restriction for the seat
 * - "HEIGHT": When there's a height restriction for the seat
 *
 * @generated from message cmp.types.v4.SeatAttribute
 */
export class SeatAttribute extends Message<SeatAttribute> {
  /**
   * The type defining the attribute itself. Ex: LIMITED_RECLINE, RESTRICTED_VIEW, AGE, etc.
   *
   * @generated from field: cmp.types.v4.SeatAttributeType type = 1;
   */
  type = SeatAttributeType.UNSPECIFIED;

  /**
   * The values associated with this attribute. Ex: "minimum age 18", "max weight 120.5 kg"
   *
   * @generated from field: repeated cmp.types.v4.SeatAttributeValue values = 3;
   */
  values: SeatAttributeValue[] = [];

  /**
   * Time periods in which this attribute is applicable
   * Usually used to indicate seasonal attributes, e.g., "Climate control" only during summer months
   * If the system only has the seasons (e.g., "Summer"), these can be represented as start and end dates
   * covering the entire season.
   * If the attribute is valid year-round, this field can be left empty.
   *
   * @generated from field: repeated cmp.types.v4.DateTimeRange valid_periods = 4;
   */
  validPeriods: DateTimeRange[] = [];

  constructor(data?: PartialMessage<SeatAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(SeatAttributeType) },
    { no: 3, name: "values", kind: "message", T: SeatAttributeValue, repeated: true },
    { no: 4, name: "valid_periods", kind: "message", T: DateTimeRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatAttribute {
    return new SeatAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatAttribute {
    return new SeatAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatAttribute {
    return new SeatAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: SeatAttribute | PlainMessage<SeatAttribute> | undefined, b: SeatAttribute | PlainMessage<SeatAttribute> | undefined): boolean {
    return proto3.util.equals(SeatAttribute, a, b);
  }
}

/**
 * Represents a value of a seat attribute along with its type and unit.
 * Examples
 * "Distance to":
 * - value: 70
 * - value_type: DISTANCE
 * - unit: CENTIMETER
 * "Minimum age":
 * - value: 18
 * - value_type: MIN_AGE
 * - unit: YEARS
 *
 * @generated from message cmp.types.v4.SeatAttributeValue
 */
export class SeatAttributeValue extends Message<SeatAttributeValue> {
  /**
   * @generated from field: float value = 1;
   */
  value = 0;

  /**
   * @generated from field: cmp.types.v4.SeatAttributeValueType value_type = 2;
   */
  valueType = SeatAttributeValueType.UNSPECIFIED;

  /**
   * @generated from field: cmp.types.v4.SeatAttributeUnit unit = 3;
   */
  unit = SeatAttributeUnit.UNSPECIFIED;

  constructor(data?: PartialMessage<SeatAttributeValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatAttributeValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "value_type", kind: "enum", T: proto3.getEnumType(SeatAttributeValueType) },
    { no: 3, name: "unit", kind: "enum", T: proto3.getEnumType(SeatAttributeUnit) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatAttributeValue {
    return new SeatAttributeValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatAttributeValue {
    return new SeatAttributeValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatAttributeValue {
    return new SeatAttributeValue().fromJsonString(jsonString, options);
  }

  static equals(a: SeatAttributeValue | PlainMessage<SeatAttributeValue> | undefined, b: SeatAttributeValue | PlainMessage<SeatAttributeValue> | undefined): boolean {
    return proto3.util.equals(SeatAttributeValue, a, b);
  }
}

/**
 * Defines the location of a seat as a clickable area within a bitmap image
 * (e.g., PNG, JPG) seat map. This information is typically used to generate
 * HTML `<area>` tags for an image map, making regions of the image interactive.
 *
 * @generated from message cmp.types.v4.BitmapSeatLocation
 */
export class BitmapSeatLocation extends Message<BitmapSeatLocation> {
  /**
   * Specifies the geometric shape of the seat's clickable area (e.g., rectangle,
   * circle, polygon). This determines how the `coordinates` field is interpreted.
   * Must be a defined `AreaType` other than `AREA_TYPE_UNSPECIFIED`.
   *
   * @generated from field: cmp.types.v4.AreaType type = 1;
   */
  type = AreaType.UNSPECIFIED;

  /**
   * A list of integer coordinates defining the shape of the seat area on the
   * bitmap image. The interpretation of these coordinates depends on the `type`
   * field and generally corresponds to the `coords` attribute of an HTML `<area>`
   * tag.
   * 
   * Examples based on `AreaType`:
   * - `AREA_TYPE_RECTANGLE`: Expects 4 coordinates: `[x1, y1, x2, y2]`,
   *   representing the top-left (x1,y1) and bottom-right (x2,y2) corners.
   *   HTML equivalent: `<area shape="rect" coords="x1,y1,x2,y2">`
   * - `AREA_TYPE_CIRCLE`: Expects 3 coordinates: `[centerX, centerY, radius]`.
   *   HTML equivalent: `<area shape="circle" coords="centerX,centerY,radius">`
   * - `AREA_TYPE_POLYGON`: Expects at least 6 coordinates (for a triangle):
   *   `[x1, y1, x2, y2, x3, y3, ..., xN, yN]`, representing the vertices of
   *   the polygon. The polygon is automatically closed by connecting the last
   *   point to the first if not explicitly done.
   *   HTML equivalent: `<area shape="poly" coords="x1,y1,x2,y2,...,xN,yN">`
   * 
   * The `min_items: 3` validation is minimum for circle areas; however, the
   * actual minimum number of coordinates depends on the `type`:
   *   - Rectangle: 4 coordinates
   *   - Circle: 3 coordinates
   *   - Polygon: 6 coordinates (for a minimal triangle)
   * `max_items` limits the complexity, e.g., for very detailed polygons.
   *
   * @generated from field: repeated int32 coordinates = 2;
   */
  coordinates: number[] = [];

  constructor(data?: PartialMessage<BitmapSeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.BitmapSeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(AreaType) },
    { no: 2, name: "coordinates", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: BitmapSeatLocation | PlainMessage<BitmapSeatLocation> | undefined, b: BitmapSeatLocation | PlainMessage<BitmapSeatLocation> | undefined): boolean {
    return proto3.util.equals(BitmapSeatLocation, a, b);
  }
}

/**
 * Defines the location or identifier of a seat within an SVG (Scalable Vector
 * Graphics) seat map. This is typically used to reference a specific element
 * (e.g., by its ID or a custom attribute) within the SVG document that
 * represents the seat.
 *
 * @generated from message cmp.types.v4.VectorSeatLocation
 */
export class VectorSeatLocation extends Message<VectorSeatLocation> {
  /**
   * The identifier (e.g., an ID, class name, or custom data attribute value)
   * of the SVG element representing the seat. This label is used to
   * programmatically find and interact with the seat's representation in the SVG.
   * Example: "seat-A1", "section-TERRACE-row-26-seat-34", "path1234".
   *
   * @generated from field: string label = 1;
   */
  label = "";

  constructor(data?: PartialMessage<VectorSeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.VectorSeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: VectorSeatLocation | PlainMessage<VectorSeatLocation> | undefined, b: VectorSeatLocation | PlainMessage<VectorSeatLocation> | undefined): boolean {
    return proto3.util.equals(VectorSeatLocation, a, b);
  }
}

/**
 * Represents the location of a single seat within a seat map.
 * A seat's location can be defined either for a vector-based (SVG) map
 * or a raster/bitmap image map. Exactly one type of location must be provided.
 *
 * @generated from message cmp.types.v4.SeatLocation
 */
export class SeatLocation extends Message<SeatLocation> {
  /**
   * Defines the seat location using one of the supported map formats.
   * This field is mandatory; either `vector` or `bitmap` must be set.
   *
   * @generated from oneof cmp.types.v4.SeatLocation.location
   */
  location: {
    /**
     * Location details for a seat in an SVG (vector) seat map.
     *
     * @generated from field: cmp.types.v4.VectorSeatLocation vector = 1;
     */
    value: VectorSeatLocation;
    case: "vector";
  } | {
    /**
     * Location details for a seat in a bitmap image seat map (e.g., PNG, JPG),
     * typically used with HTML image maps.
     *
     * @generated from field: cmp.types.v4.BitmapSeatLocation bitmap = 2;
     */
    value: BitmapSeatLocation;
    case: "bitmap";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: VectorSeatLocation, oneof: "location" },
    { no: 2, name: "bitmap", kind: "message", T: BitmapSeatLocation, oneof: "location" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatLocation {
    return new SeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatLocation {
    return new SeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatLocation {
    return new SeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: SeatLocation | PlainMessage<SeatLocation> | undefined, b: SeatLocation | PlainMessage<SeatLocation> | undefined): boolean {
    return proto3.util.equals(SeatLocation, a, b);
  }
}

