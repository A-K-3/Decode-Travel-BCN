// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v4/common.proto (package cmp.types.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// ## Camino Messenger Protocol (CMP) Types Package - Common Definitions
//
// This file contains commonly used message types for the Camino Messenger Protocol
// (CMP), forming a foundational part of CMP message structures.
//
// **Understanding Protobuf Default Values:** When parsing Protocol Buffer messages,
// there's a distinction between a field being absent and a field being present with
// its default value. For non-message fields (like integers, enums, strings), if a
// field is not explicitly set when a message is serialized, it will deserialize
// with a default value (e.g., 0 for integers/enums, empty string for strings).
//
// Consequently, for enums within CMP:
// - The '0' value is conventionally defined as `*_UNSPECIFIED`.
// - It's often impossible to distinguish if `*_UNSPECIFIED` (value 0) was
//   explicitly set or if the field was omitted.
// - Therefore, `*_UNSPECIFIED` is typically treated as an invalid or not-set state
//   in application logic, often enforced by validation rules (e.g., `not_in: [0]`).
// - If an enum field is optional, a value of `0` might imply the field was not
//   provided. If required, `0` is usually disallowed.
//
// This principle also applies to other field types, though validation logic might
// be more nuanced than a simple "not equal to 0" check.
//
// **Order in Repeated Fields:**
//
// Protobuf preserves the order of elements within a `repeated` field. This order
// can be semantically significant. For example, a sequence of travel legs in a trip
// should be specified in the intended chronological or logical order.

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { EVMAddress } from "./evm_address_pb";

/**
 * @generated from enum cmp.types.v4.AlertCode
 */
export enum AlertCode {
  /**
   * @generated from enum value: ALERT_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The request was successful but there is no content to return.
   * This can be due to filters or criteria that resulted in no matching data.
   *
   * @generated from enum value: ALERT_CODE_NO_CONTENT = 1;
   */
  NO_CONTENT = 1,

  /**
   * The version used is deprecated and may not be supported in the future.
   *
   * @generated from enum value: ALERT_CODE_DEPRECATED_VERSION = 2;
   */
  DEPRECATED_VERSION = 2,

  /**
   * One or more requested languages are not supported.
   *
   * @generated from enum value: ALERT_CODE_LANGUAGE_NOT_SUPPORTED = 3;
   */
  LANGUAGE_NOT_SUPPORTED = 3,

  /**
   * An informational alert that does not indicate an error or warning.
   *
   * @generated from enum value: ALERT_CODE_INFORMATIONAL = 4;
   */
  INFORMATIONAL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AlertCode)
proto3.util.setEnumType(AlertCode, "cmp.types.v4.AlertCode", [
  { no: 0, name: "ALERT_CODE_UNSPECIFIED" },
  { no: 1, name: "ALERT_CODE_NO_CONTENT" },
  { no: 2, name: "ALERT_CODE_DEPRECATED_VERSION" },
  { no: 3, name: "ALERT_CODE_LANGUAGE_NOT_SUPPORTED" },
  { no: 4, name: "ALERT_CODE_INFORMATIONAL" },
]);

/**
 * @generated from enum cmp.types.v4.ErrorCode
 */
export enum ErrorCode {
  /**
   * @generated from enum value: ERROR_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The request did not conform to the expected Protobuf schema and/or validation rules.
   *
   * @generated from enum value: ERROR_CODE_INVALID_PROTO = 1;
   */
  INVALID_PROTO = 1,

  /**
   * The request contained invalid or unrecognized identifiers (e.g. ExpiringUUIDs).
   *
   * @generated from enum value: ERROR_CODE_INVALID_IDENTIFIERS = 2;
   */
  INVALID_IDENTIFIERS = 2,

  /**
   * The request contained invalid or unsupported currency codes.
   *
   * @generated from enum value: ERROR_CODE_INVALID_CURRENCY = 3;
   */
  INVALID_CURRENCY = 3,

  /**
   * The request contained fields which are not supported (and can't be ignored).
   *
   * @generated from enum value: ERROR_CODE_UNIMPLEMENTED = 4;
   */
  UNIMPLEMENTED = 4,

  /**
   * The requester is not authorized to perform the operation.
   *
   * @generated from enum value: ERROR_CODE_UNAUTHORIZED = 5;
   */
  UNAUTHORIZED = 5,

  /**
   * An internal server error occurred.
   *
   * @generated from enum value: ERROR_CODE_INTERNAL = 6;
   */
  INTERNAL = 6,

  /**
   * The service is temporarily unavailable.
   *
   * @generated from enum value: ERROR_CODE_TEMPORARY_UNAVAILABLE = 7;
   */
  TEMPORARY_UNAVAILABLE = 7,

  /**
   * The request exceeded the allowed rate limit.
   *
   * @generated from enum value: ERROR_CODE_RATE_LIMIT_EXCEEDED = 8;
   */
  RATE_LIMIT_EXCEEDED = 8,

  /**
   * An error occurred in the context of the overall business process.
   * This could involve issues like proto-valid field values which are invalid in the context of the process
   * payment failures, or other domain-specific errors.
   *
   * @generated from enum value: ERROR_CODE_BUSINESS_PROCESS_ERROR = 9;
   */
  BUSINESS_PROCESS_ERROR = 9,

  /**
   * An error occurred while interacting with the blockchain.
   *
   * @generated from enum value: ERROR_CODE_BLOCKCHAIN_ERROR = 10;
   */
  BLOCKCHAIN_ERROR = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorCode)
proto3.util.setEnumType(ErrorCode, "cmp.types.v4.ErrorCode", [
  { no: 0, name: "ERROR_CODE_UNSPECIFIED" },
  { no: 1, name: "ERROR_CODE_INVALID_PROTO" },
  { no: 2, name: "ERROR_CODE_INVALID_IDENTIFIERS" },
  { no: 3, name: "ERROR_CODE_INVALID_CURRENCY" },
  { no: 4, name: "ERROR_CODE_UNIMPLEMENTED" },
  { no: 5, name: "ERROR_CODE_UNAUTHORIZED" },
  { no: 6, name: "ERROR_CODE_INTERNAL" },
  { no: 7, name: "ERROR_CODE_TEMPORARY_UNAVAILABLE" },
  { no: 8, name: "ERROR_CODE_RATE_LIMIT_EXCEEDED" },
  { no: 9, name: "ERROR_CODE_BUSINESS_PROCESS_ERROR" },
  { no: 10, name: "ERROR_CODE_BLOCKCHAIN_ERROR" },
]);

/**
 * Header provides common metadata for CMP messages.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/common.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v4/common.proto.dot.svg)
 *
 * @generated from message cmp.types.v4.Header
 */
export class Header extends Message<Header> {
  /**
   * The version of the CMP bot or component processing/generating the message. This
   * field is crucial for transparency, version compatibility checks, and
   * troubleshooting, especially when different components or partners might be
   * running different versions.
   * 
   *   - In requests and responses by an external system (e.g., a "partner plugin")
   *     that may not know the bot's specific version, this field can be sent with a
   *     default `Version` message (e.g., major:0, minor:0, patch:0).
   *   - In requests and responses generated or modified by a CMP bot/component,
   *     this field **must** be populated with the actual semantic version of that
   *     bot/component.
   * 
   * This field is required to ensure version information is always available.
   *
   * @generated from field: cmp.types.v4.Version version = 1;
   */
  version?: Version;

  /**
   * Optional. The end-user's wallet address (e.g., an EVM-compatible address) that
   * can be used for personalization, user identification, or linking activities to
   * a specific user account on a blockchain-based system.
   *
   * @generated from field: cmp.types.v4.EVMAddress end_user_wallet_address = 2;
   */
  endUserWalletAddress?: EVMAddress;

  /**
   * An optional identifier for external sessions, aiding in tracking and continuity
   * across sessions.
   * This is specified by the initiating system (e.g., a partner plugin)
   * and can be used to identify not only the request/response pair but also
   * subsequent interactions related to the same business case.
   * This field if given in the request header needs to be mirrored in the
   * response header to maintain session context.
   *
   * @generated from field: string external_session_id = 3;
   */
  externalSessionId = "";

  constructor(data?: PartialMessage<Header>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Header";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "message", T: Version },
    { no: 2, name: "end_user_wallet_address", kind: "message", T: EVMAddress },
    { no: 3, name: "external_session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Header {
    return new Header().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJsonString(jsonString, options);
  }

  static equals(a: Header | PlainMessage<Header> | undefined, b: Header | PlainMessage<Header> | undefined): boolean {
    return proto3.util.equals(Header, a, b);
  }
}

/**
 * Version represents a semantic version (Major.Minor.Patch).
 *
 * @generated from message cmp.types.v4.Version
 */
export class Version extends Message<Version> {
  /**
   * Major version. Incremented for incompatible API changes.
   *
   * @generated from field: uint32 major = 1;
   */
  major = 0;

  /**
   * Minor version. Incremented for adding functionality in a backwards-compatible
   * manner.
   *
   * @generated from field: uint32 minor = 2;
   */
  minor = 0;

  /**
   * Patch version. Incremented for backwards-compatible bug fixes.
   *
   * @generated from field: uint32 patch = 3;
   */
  patch = 0;

  constructor(data?: PartialMessage<Version>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Version";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "major", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "minor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "patch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Version {
    return new Version().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Version {
    return new Version().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Version {
    return new Version().fromJsonString(jsonString, options);
  }

  static equals(a: Version | PlainMessage<Version> | undefined, b: Version | PlainMessage<Version> | undefined): boolean {
    return proto3.util.equals(Version, a, b);
  }
}

/**
 * RequestHeader wraps the common base header and includes response-specific info.
 *
 * @generated from message cmp.types.v4.RequestHeader
 */
export class RequestHeader extends Message<RequestHeader> {
  /**
   * The base header information common to all CMP messages.
   *
   * @generated from field: cmp.types.v4.Header base_header = 1;
   */
  baseHeader?: Header;

  constructor(data?: PartialMessage<RequestHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.RequestHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_header", kind: "message", T: Header },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestHeader {
    return new RequestHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestHeader {
    return new RequestHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestHeader {
    return new RequestHeader().fromJsonString(jsonString, options);
  }

  static equals(a: RequestHeader | PlainMessage<RequestHeader> | undefined, b: RequestHeader | PlainMessage<RequestHeader> | undefined): boolean {
    return proto3.util.equals(RequestHeader, a, b);
  }
}

/**
 * The SuccessResponseHeader wraps the common base header and includes response-specific info.
 *
 * @generated from message cmp.types.v4.SuccessResponseHeader
 */
export class SuccessResponseHeader extends Message<SuccessResponseHeader> {
  /**
   * The base header information common to all CMP messages.
   *
   * @generated from field: cmp.types.v4.Header base_header = 1;
   */
  baseHeader?: Header;

  /**
   * A list of alerts providing more detailed information about the response
   *
   * @generated from field: repeated cmp.types.v4.Alert alerts = 2;
   */
  alerts: Alert[] = [];

  constructor(data?: PartialMessage<SuccessResponseHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.SuccessResponseHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_header", kind: "message", T: Header },
    { no: 2, name: "alerts", kind: "message", T: Alert, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuccessResponseHeader {
    return new SuccessResponseHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuccessResponseHeader {
    return new SuccessResponseHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuccessResponseHeader {
    return new SuccessResponseHeader().fromJsonString(jsonString, options);
  }

  static equals(a: SuccessResponseHeader | PlainMessage<SuccessResponseHeader> | undefined, b: SuccessResponseHeader | PlainMessage<SuccessResponseHeader> | undefined): boolean {
    return proto3.util.equals(SuccessResponseHeader, a, b);
  }
}

/**
 * The ErrorResponseHeader wraps the common base header and includes reasons for failure.
 *
 * @generated from message cmp.types.v4.ErrorResponseHeader
 */
export class ErrorResponseHeader extends Message<ErrorResponseHeader> {
  /**
   * The base header information common to all CMP messages.
   *
   * @generated from field: cmp.types.v4.Header base_header = 1;
   */
  baseHeader?: Header;

  /**
   * A list of errors providing more detailed information about the
   * response failure.
   *
   * @generated from field: repeated cmp.types.v4.Error errors = 2;
   */
  errors: Error[] = [];

  constructor(data?: PartialMessage<ErrorResponseHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.ErrorResponseHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_header", kind: "message", T: Header },
    { no: 2, name: "errors", kind: "message", T: Error, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorResponseHeader {
    return new ErrorResponseHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorResponseHeader {
    return new ErrorResponseHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorResponseHeader {
    return new ErrorResponseHeader().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorResponseHeader | PlainMessage<ErrorResponseHeader> | undefined, b: ErrorResponseHeader | PlainMessage<ErrorResponseHeader> | undefined): boolean {
    return proto3.util.equals(ErrorResponseHeader, a, b);
  }
}

/**
 * Alert provides detailed feedback which can be a warning, or
 * informational message.
 *
 * @generated from message cmp.types.v4.Alert
 */
export class Alert extends Message<Alert> {
  /**
   * @generated from field: cmp.types.v4.AlertCode code = 3;
   */
  code = AlertCode.UNSPECIFIED;

  /**
   * The optional human-readable alert message to further specify the alert.
   *
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<Alert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Alert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "code", kind: "enum", T: proto3.getEnumType(AlertCode) },
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alert {
    return new Alert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJsonString(jsonString, options);
  }

  static equals(a: Alert | PlainMessage<Alert> | undefined, b: Alert | PlainMessage<Alert> | undefined): boolean {
    return proto3.util.equals(Alert, a, b);
  }
}

/**
 * Errors provides detailed feedback about why a request failed.
 *
 * @generated from message cmp.types.v4.Error
 */
export class Error extends Message<Error> {
  /**
   * @generated from field: cmp.types.v4.ErrorCode code = 1;
   */
  code = ErrorCode.UNSPECIFIED;

  /**
   * An optional human-readable error message to further specify the error.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v4.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ErrorCode) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

