// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v3/seat_map.proto (package cmp.types.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Int32Value, Message, proto3 } from "@bufbuild/protobuf";
import { LocalizedString } from "../v1/localized_pb";
import { Image } from "./file_pb";
import { LocalizedDescriptionSet } from "../v1/description_pb";
import { Language } from "../v1/language_pb";

/**
 * Enumerates the types of areas that can be defined within a seat map. This is used
 * for specifying the shape of regions in bitmap images.
 *
 * @generated from enum cmp.types.v3.AreaType
 */
export enum AreaType {
  /**
   * @generated from enum value: AREA_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: AREA_TYPE_RECTANGLE = 1;
   */
  RECTANGLE = 1,

  /**
   * @generated from enum value: AREA_TYPE_CIRCLE = 2;
   */
  CIRCLE = 2,

  /**
   * @generated from enum value: AREA_TYPE_POLYGON = 3;
   */
  POLYGON = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AreaType)
proto3.util.setEnumType(AreaType, "cmp.types.v3.AreaType", [
  { no: 0, name: "AREA_TYPE_UNSPECIFIED" },
  { no: 1, name: "AREA_TYPE_RECTANGLE" },
  { no: 2, name: "AREA_TYPE_CIRCLE" },
  { no: 3, name: "AREA_TYPE_POLYGON" },
]);

/**
 * Represents a basic seat with optional features and restrictions. Each seat has a
 * unique identifier, a location within the seat map, and can have various static
 * features and restrictions associated with it.
 *
 * @generated from message cmp.types.v3.Seat
 */
export class Seat extends Message<Seat> {
  /**
   * Unique identifier for the seat, such as "12B" or "A26". This identifier must be
   * unique within the section to which this seat belongs.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The location of the seat within the seat map. This can be defined using either
   * a vector (SVG) or bitmap format.
   *
   * @generated from field: cmp.types.v3.SeatLocation location = 2;
   */
  location?: SeatLocation;

  /**
   * Static features associated with the seat, such as type, amenities, etc.
   *
   * @generated from field: repeated cmp.types.v3.LocalizedSeatAttributeSet features = 3;
   */
  features: LocalizedSeatAttributeSet[] = [];

  /**
   * Restrictions associated with the seat, such as age limits or accessibility requirements.
   *
   * @generated from field: repeated cmp.types.v3.LocalizedSeatAttributeSet restrictions = 4;
   */
  restrictions: LocalizedSeatAttributeSet[] = [];

  constructor(data?: PartialMessage<Seat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.Seat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "location", kind: "message", T: SeatLocation },
    { no: 3, name: "features", kind: "message", T: LocalizedSeatAttributeSet, repeated: true },
    { no: 4, name: "restrictions", kind: "message", T: LocalizedSeatAttributeSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Seat {
    return new Seat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Seat {
    return new Seat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Seat {
    return new Seat().fromJsonString(jsonString, options);
  }

  static equals(a: Seat | PlainMessage<Seat> | undefined, b: Seat | PlainMessage<Seat> | undefined): boolean {
    return proto3.util.equals(Seat, a, b);
  }
}

/**
 * List of seats
 *
 * @generated from message cmp.types.v3.SeatList
 */
export class SeatList extends Message<SeatList> {
  /**
   * @generated from field: repeated cmp.types.v3.Seat seats = 1;
   */
  seats: Seat[] = [];

  constructor(data?: PartialMessage<SeatList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seats", kind: "message", T: Seat, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatList {
    return new SeatList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatList {
    return new SeatList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatList {
    return new SeatList().fromJsonString(jsonString, options);
  }

  static equals(a: SeatList | PlainMessage<SeatList> | undefined, b: SeatList | PlainMessage<SeatList> | undefined): boolean {
    return proto3.util.equals(SeatList, a, b);
  }
}

/**
 * A Section represents a distinct area within a venue, which can be defined by
 * various attributes. It can be a block of rows in a theater, a specific area in a
 * concert venue such as the stage or standing area, a section of seating in a
 * stadium, or a section in an airplane. Each Section is uniquely identified and can
 * contain information about its seats, layout, and additional properties.
 *
 * @generated from message cmp.types.v3.Section
 */
export class Section extends Message<Section> {
  /**
   * Level, section or row identifier, e.g., "Upper", "Balcony" or "Section 101",
   * "Orchestra" or "A", "12". Must be unique for each section.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * List of localized names Human readable names of the section
   *
   * @generated from field: repeated cmp.types.v1.LocalizedString names = 2;
   */
  names: LocalizedString[] = [];

  /**
   * Seats in this section.
   *
   * @generated from oneof cmp.types.v3.Section.seat_info
   */
  seatInfo: {
    /**
     * List of seats in this section.
     *
     * @generated from field: cmp.types.v3.SeatList seat_list = 3;
     */
    value: SeatList;
    case: "seatList";
  } | {
    /**
     * Total number of seats in this section as an integer.
     *
     * @generated from field: google.protobuf.Int32Value total_seats = 4;
     */
    value: Int32Value;
    case: "totalSeats";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Image that provides a visual representation of the section's layout, which can
   * be either a vector (SVG) or bitmap image.
   * 
   * If set, it is assumed that this image is used for locating seats within the
   * section. (the `SeatLocation` message type in the `Seat` message above is
   * used to represent seat location inside this image).
   *
   * @generated from field: cmp.types.v3.Image image = 5;
   */
  image?: Image;

  /**
   * A list of localized descriptions for this section, useful for providing
   * information about features and amenities in multiple languages.
   *
   * @generated from field: repeated cmp.types.v1.LocalizedDescriptionSet localized_descriptions = 6;
   */
  localizedDescriptions: LocalizedDescriptionSet[] = [];

  /**
   * Nested sections within this section, allowing for a hierarchical representation
   * of the venue's layout.
   *
   * @generated from field: repeated cmp.types.v3.Section sections = 7;
   */
  sections: Section[] = [];

  constructor(data?: PartialMessage<Section>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.Section";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "names", kind: "message", T: LocalizedString, repeated: true },
    { no: 3, name: "seat_list", kind: "message", T: SeatList, oneof: "seat_info" },
    { no: 4, name: "total_seats", kind: "message", T: Int32Value, oneof: "seat_info" },
    { no: 5, name: "image", kind: "message", T: Image },
    { no: 6, name: "localized_descriptions", kind: "message", T: LocalizedDescriptionSet, repeated: true },
    { no: 7, name: "sections", kind: "message", T: Section, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Section {
    return new Section().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Section {
    return new Section().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Section {
    return new Section().fromJsonString(jsonString, options);
  }

  static equals(a: Section | PlainMessage<Section> | undefined, b: Section | PlainMessage<Section> | undefined): boolean {
    return proto3.util.equals(Section, a, b);
  }
}

/**
 * High-level representation of a seat map, which defines the layout and structure
 * of seating within a venue. This message provides a comprehensive overview of the
 * seating arrangement, including sections, images, and localized descriptions.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/seat_map.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/seat_map.proto.dot.svg)
 *
 * @generated from message cmp.types.v3.SeatMap
 */
export class SeatMap extends Message<SeatMap> {
  /**
   * Unique identifier for the seat map
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * A list of sections within the seat map. Each section represents a distinct area
   * within the venue, such as rows, sections, levels, or blocks of seats. This
   * field is recursive, allowing for hierarchical structuring of the seating
   * layout.
   *
   * @generated from field: repeated cmp.types.v3.Section sections = 2;
   */
  sections: Section[] = [];

  /**
   * Image that provides a visual representation of the seat map, illustrating the
   * location and arrangement of seats. The image can be in vector format (SVG) or
   * bitmap format.
   *
   * @generated from field: cmp.types.v3.Image image = 3;
   */
  image?: Image;

  /**
   * A list of localized descriptions for the seat map. This can be used to describe
   * features and amenities of the seating arrangement in multiple languages.
   * The languages should match those requested in SeatMapRequest
   *
   * @generated from field: repeated cmp.types.v1.LocalizedDescriptionSet localized_descriptions = 4;
   */
  localizedDescriptions: LocalizedDescriptionSet[] = [];

  constructor(data?: PartialMessage<SeatMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sections", kind: "message", T: Section, repeated: true },
    { no: 3, name: "image", kind: "message", T: Image },
    { no: 4, name: "localized_descriptions", kind: "message", T: LocalizedDescriptionSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMap {
    return new SeatMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMap {
    return new SeatMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMap {
    return new SeatMap().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMap | PlainMessage<SeatMap> | undefined, b: SeatMap | PlainMessage<SeatMap> | undefined): boolean {
    return proto3.util.equals(SeatMap, a, b);
  }
}

/**
 * List of _only_ seat IDs to be used for seat selection or seat availability.
 *
 * @generated from message cmp.types.v3.SeatInventory
 */
export class SeatInventory extends Message<SeatInventory> {
  /**
   * List of seat IDs
   *
   * @generated from field: repeated string ids = 1;
   */
  ids: string[] = [];

  constructor(data?: PartialMessage<SeatInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatInventory {
    return new SeatInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatInventory {
    return new SeatInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatInventory {
    return new SeatInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SeatInventory | PlainMessage<SeatInventory> | undefined, b: SeatInventory | PlainMessage<SeatInventory> | undefined): boolean {
    return proto3.util.equals(SeatInventory, a, b);
  }
}

/**
 * Represents the inventory of seats for a specific section and all its inner
 * sections. This message is used for both seat availability and seat selection
 * purposes, providing information about either the remaining or selected seats
 * within the section.
 *
 * @generated from message cmp.types.v3.SectionInventory
 */
export class SectionInventory extends Message<SectionInventory> {
  /**
   * Unique identifier for the section. Must be unique within the seat map.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from oneof cmp.types.v3.SectionInventory.seat_info
   */
  seatInfo: {
    /**
     * List of individual seat IDs within this section.
     *
     * @generated from field: cmp.types.v3.SeatInventory seat_list = 2;
     */
    value: SeatInventory;
    case: "seatList";
  } | {
    /**
     * Seat count in this section, representing either the remaining seats for
     * availability purposes or the selected seats for seat selection messages.
     * 
     * This field is intended for sections without individual seat details, such as
     * standing areas at a concert or an arena.
     *
     * @generated from field: google.protobuf.Int32Value seat_count = 3;
     */
    value: Int32Value;
    case: "seatCount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Nested inner sections within this section, allowing for a hierarchical
   * representation of seat inventory. Each inner section can have its own seat
   * information and further nested sections.
   *
   * @generated from field: repeated cmp.types.v3.SectionInventory sections = 4;
   */
  sections: SectionInventory[] = [];

  constructor(data?: PartialMessage<SectionInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SectionInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "seat_list", kind: "message", T: SeatInventory, oneof: "seat_info" },
    { no: 3, name: "seat_count", kind: "message", T: Int32Value, oneof: "seat_info" },
    { no: 4, name: "sections", kind: "message", T: SectionInventory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SectionInventory {
    return new SectionInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SectionInventory {
    return new SectionInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SectionInventory {
    return new SectionInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SectionInventory | PlainMessage<SectionInventory> | undefined, b: SectionInventory | PlainMessage<SectionInventory> | undefined): boolean {
    return proto3.util.equals(SectionInventory, a, b);
  }
}

/**
 * Represents the inventory of seats for a specific seat map, used for both seat
 * selection and seat availability purposes. This message provides a comprehensive
 * overview of the seating inventory, including detailed information about each
 * section and its inner sections.
 *
 * @generated from message cmp.types.v3.SeatMapInventory
 */
export class SeatMapInventory extends Message<SeatMapInventory> {
  /**
   * Unique identifier for the seat map that this Inventory refers to.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * A list of seat inventories for each section within the seat map. This field
   * includes detailed seat information and supports nested sections, allowing for a
   * hierarchical representation of the seating arrangement.
   *
   * @generated from field: repeated cmp.types.v3.SectionInventory sections = 2;
   */
  sections: SectionInventory[] = [];

  constructor(data?: PartialMessage<SeatMapInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatMapInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sections", kind: "message", T: SectionInventory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapInventory {
    return new SeatMapInventory().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapInventory | PlainMessage<SeatMapInventory> | undefined, b: SeatMapInventory | PlainMessage<SeatMapInventory> | undefined): boolean {
    return proto3.util.equals(SeatMapInventory, a, b);
  }
}

/**
 * @generated from message cmp.types.v3.LocalizedSeatAttributeSet
 */
export class LocalizedSeatAttributeSet extends Message<LocalizedSeatAttributeSet> {
  /**
   * @generated from field: cmp.types.v1.Language language = 1;
   */
  language = Language.UNSPECIFIED;

  /**
   * @generated from field: repeated cmp.types.v3.SeatAttribute seat_attributes = 2;
   */
  seatAttributes: SeatAttribute[] = [];

  constructor(data?: PartialMessage<LocalizedSeatAttributeSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.LocalizedSeatAttributeSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "language", kind: "enum", T: proto3.getEnumType(Language) },
    { no: 2, name: "seat_attributes", kind: "message", T: SeatAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedSeatAttributeSet {
    return new LocalizedSeatAttributeSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedSeatAttributeSet {
    return new LocalizedSeatAttributeSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedSeatAttributeSet {
    return new LocalizedSeatAttributeSet().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedSeatAttributeSet | PlainMessage<LocalizedSeatAttributeSet> | undefined, b: LocalizedSeatAttributeSet | PlainMessage<LocalizedSeatAttributeSet> | undefined): boolean {
    return proto3.util.equals(LocalizedSeatAttributeSet, a, b);
  }
}

/**
 * Defines a static attribute for a seat, which can be used for specifying features
 * and restrictions. Attributes include a name, a human-readable description, and a
 * value that can be used for various conditions or restrictions.
 * 
 *
 * @generated from message cmp.types.v3.SeatAttribute
 */
export class SeatAttribute extends Message<SeatAttribute> {
  /**
   * Name of the attribute, used to identify the feature or restriction.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Human-readable description of the attribute, providing more details about its purpose.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Integer value associated with the attribute, which can be used for conditions
   * or restrictions, such as "min_age".
   *
   * @generated from field: int32 value = 3;
   */
  value = 0;

  constructor(data?: PartialMessage<SeatAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatAttribute {
    return new SeatAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatAttribute {
    return new SeatAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatAttribute {
    return new SeatAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: SeatAttribute | PlainMessage<SeatAttribute> | undefined, b: SeatAttribute | PlainMessage<SeatAttribute> | undefined): boolean {
    return proto3.util.equals(SeatAttribute, a, b);
  }
}

/**
 * Defines the location of a seat within a bitmap image seat map. This information
 * is generally used with the HTML `area` tag to specify clickable regions.
 *
 * @generated from message cmp.types.v3.BitmapSeatLocation
 */
export class BitmapSeatLocation extends Message<BitmapSeatLocation> {
  /**
   * The type of area defining the seat location, such as rectangle, circle, or polygon.
   *
   * @generated from field: cmp.types.v3.AreaType type = 1;
   */
  type = AreaType.UNSPECIFIED;

  /**
   * Coordinates defining the area. The format of the coordinates depends on the
   * area type (e.g., top-left (x1,y1) and bottom-right (x2,y2) corners for a
   * rectangle: `<area shape="rect" coords="x1,y1,x2,y2"`).
   *
   * @generated from field: repeated int32 coordinates = 2;
   */
  coordinates: number[] = [];

  constructor(data?: PartialMessage<BitmapSeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.BitmapSeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(AreaType) },
    { no: 2, name: "coordinates", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BitmapSeatLocation {
    return new BitmapSeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: BitmapSeatLocation | PlainMessage<BitmapSeatLocation> | undefined, b: BitmapSeatLocation | PlainMessage<BitmapSeatLocation> | undefined): boolean {
    return proto3.util.equals(BitmapSeatLocation, a, b);
  }
}

/**
 * Defines the location of a seat within an SVG (vector) seat map. This is typically
 * used for labeling elements within the SVG.
 *
 * @generated from message cmp.types.v3.VectorSeatLocation
 */
export class VectorSeatLocation extends Message<VectorSeatLocation> {
  /**
   * Label for the seat location in the SVG, e.g., "section-TERRACE-26-34-2-label".
   *
   * @generated from field: string label = 1;
   */
  label = "";

  constructor(data?: PartialMessage<VectorSeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.VectorSeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorSeatLocation {
    return new VectorSeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: VectorSeatLocation | PlainMessage<VectorSeatLocation> | undefined, b: VectorSeatLocation | PlainMessage<VectorSeatLocation> | undefined): boolean {
    return proto3.util.equals(VectorSeatLocation, a, b);
  }
}

/**
 * Represents the location of a seat within a seat map, which can be defined using
 * either a vector (SVG) or bitmap format. This message encapsulates both types of
 * seat location definitions.
 *
 * @generated from message cmp.types.v3.SeatLocation
 */
export class SeatLocation extends Message<SeatLocation> {
  /**
   * One of the possible seat location types: vector (SVG) or bitmap.
   *
   * @generated from oneof cmp.types.v3.SeatLocation.location
   */
  location: {
    /**
     * Vector-based seat location, used for SVG maps.
     *
     * @generated from field: cmp.types.v3.VectorSeatLocation vector = 1;
     */
    value: VectorSeatLocation;
    case: "vector";
  } | {
    /**
     * Bitmap-based seat location, used for HTML image maps.
     *
     * @generated from field: cmp.types.v3.BitmapSeatLocation bitmap = 2;
     */
    value: BitmapSeatLocation;
    case: "bitmap";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SeatLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.SeatLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: VectorSeatLocation, oneof: "location" },
    { no: 2, name: "bitmap", kind: "message", T: BitmapSeatLocation, oneof: "location" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatLocation {
    return new SeatLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatLocation {
    return new SeatLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatLocation {
    return new SeatLocation().fromJsonString(jsonString, options);
  }

  static equals(a: SeatLocation | PlainMessage<SeatLocation> | undefined, b: SeatLocation | PlainMessage<SeatLocation> | undefined): boolean {
    return proto3.util.equals(SeatLocation, a, b);
  }
}

