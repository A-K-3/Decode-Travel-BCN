// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v3/traveller.proto (package cmp.types.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Date } from "../v1/date_pb";
import { Country } from "../v2/country_pb";
import { ContactInfo } from "../v2/contact_info_pb";
import { Document } from "../v1/document_pb";

/**
 * Traveller Type
 *
 * @generated from enum cmp.types.v3.TravellerType
 */
export enum TravellerType {
  /**
   * @generated from enum value: TRAVELLER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TRAVELLER_TYPE_ADULT = 1;
   */
  ADULT = 1,

  /**
   * @generated from enum value: TRAVELLER_TYPE_CHILD = 2;
   */
  CHILD = 2,

  /**
   * @generated from enum value: TRAVELLER_TYPE_INFANT = 3;
   */
  INFANT = 3,

  /**
   * @generated from enum value: TRAVELLER_TYPE_SENIOR = 4;
   */
  SENIOR = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TravellerType)
proto3.util.setEnumType(TravellerType, "cmp.types.v3.TravellerType", [
  { no: 0, name: "TRAVELLER_TYPE_UNSPECIFIED" },
  { no: 1, name: "TRAVELLER_TYPE_ADULT" },
  { no: 2, name: "TRAVELLER_TYPE_CHILD" },
  { no: 3, name: "TRAVELLER_TYPE_INFANT" },
  { no: 4, name: "TRAVELLER_TYPE_SENIOR" },
]);

/**
 * Gender Type
 *
 * @generated from enum cmp.types.v3.GenderType
 */
export enum GenderType {
  /**
   * @generated from enum value: GENDER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: GENDER_TYPE_MALE = 1;
   */
  MALE = 1,

  /**
   * @generated from enum value: GENDER_TYPE_FEMALE = 2;
   */
  FEMALE = 2,

  /**
   * @generated from enum value: GENDER_TYPE_NONBINARY = 3;
   */
  NONBINARY = 3,

  /**
   * @generated from enum value: GENDER_TYPE_AGENDER = 4;
   */
  AGENDER = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(GenderType)
proto3.util.setEnumType(GenderType, "cmp.types.v3.GenderType", [
  { no: 0, name: "GENDER_TYPE_UNSPECIFIED" },
  { no: 1, name: "GENDER_TYPE_MALE" },
  { no: 2, name: "GENDER_TYPE_FEMALE" },
  { no: 3, name: "GENDER_TYPE_NONBINARY" },
  { no: 4, name: "GENDER_TYPE_AGENDER" },
]);

/**
 * Traveller relationship
 *
 * @generated from enum cmp.types.v3.TravellerRelationship
 */
export enum TravellerRelationship {
  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_OTHER = 1;
   */
  OTHER = 1,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_FATHER = 2;
   */
  FATHER = 2,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_MOTHER = 3;
   */
  MOTHER = 3,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_SON = 4;
   */
  SON = 4,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_DAUGHTER = 5;
   */
  DAUGHTER = 5,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_SPOUSE = 6;
   */
  SPOUSE = 6,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_BROTHER = 7;
   */
  BROTHER = 7,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_SISTER = 8;
   */
  SISTER = 8,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_FAMILY_MEMBER = 9;
   */
  FAMILY_MEMBER = 9,

  /**
   * @generated from enum value: TRAVELLER_RELATIONSHIP_ADOPTED = 10;
   */
  ADOPTED = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(TravellerRelationship)
proto3.util.setEnumType(TravellerRelationship, "cmp.types.v3.TravellerRelationship", [
  { no: 0, name: "TRAVELLER_RELATIONSHIP_UNSPECIFIED" },
  { no: 1, name: "TRAVELLER_RELATIONSHIP_OTHER" },
  { no: 2, name: "TRAVELLER_RELATIONSHIP_FATHER" },
  { no: 3, name: "TRAVELLER_RELATIONSHIP_MOTHER" },
  { no: 4, name: "TRAVELLER_RELATIONSHIP_SON" },
  { no: 5, name: "TRAVELLER_RELATIONSHIP_DAUGHTER" },
  { no: 6, name: "TRAVELLER_RELATIONSHIP_SPOUSE" },
  { no: 7, name: "TRAVELLER_RELATIONSHIP_BROTHER" },
  { no: 8, name: "TRAVELLER_RELATIONSHIP_SISTER" },
  { no: 9, name: "TRAVELLER_RELATIONSHIP_FAMILY_MEMBER" },
  { no: 10, name: "TRAVELLER_RELATIONSHIP_ADOPTED" },
]);

/**
 * Traveller
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/traveller.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/traveller.proto.dot.svg)
 *
 * @generated from message cmp.types.v3.BasicTraveller
 */
export class BasicTraveller extends Message<BasicTraveller> {
  /**
   * Guest number, the lowest number is the lead-pax. This ID is also used for
   * referencing services linked to specific participants, like baggage.
   * the traveller_id must be kept consistent between the search request and response.
   * Conclusively if the request specifies traveller 0 and 1, then the response also refers
   * to these traveller numbers. If the request specifies 1 and 2 or 10 and 20, then the
   * response also returns these references.
   * The traveller_id is specified in each unit and only detailed once in the search response
   * repeated travellers field
   *
   * @generated from field: int32 traveller_id = 1;
   */
  travellerId = 0;

  /**
   * Traveller type from enum below
   *
   * @generated from field: cmp.types.v3.TravellerType type = 2;
   */
  type = TravellerType.UNSPECIFIED;

  /**
   * Birthdate
   *
   * @generated from field: cmp.types.v1.Date birthdate = 3;
   */
  birthdate?: Date;

  /**
   * The country code for the nationality of the traveller.
   *
   * @generated from field: cmp.types.v2.Country nationality = 4;
   */
  nationality = Country.UNSPECIFIED;

  constructor(data?: PartialMessage<BasicTraveller>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.BasicTraveller";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "traveller_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TravellerType) },
    { no: 3, name: "birthdate", kind: "message", T: Date },
    { no: 4, name: "nationality", kind: "enum", T: proto3.getEnumType(Country) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicTraveller {
    return new BasicTraveller().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicTraveller {
    return new BasicTraveller().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicTraveller {
    return new BasicTraveller().fromJsonString(jsonString, options);
  }

  static equals(a: BasicTraveller | PlainMessage<BasicTraveller> | undefined, b: BasicTraveller | PlainMessage<BasicTraveller> | undefined): boolean {
    return proto3.util.equals(BasicTraveller, a, b);
  }
}

/**
 * @generated from message cmp.types.v3.ExtensiveTraveller
 */
export class ExtensiveTraveller extends Message<ExtensiveTraveller> {
  /**
   * Guest number. The lowest number is the lead-pax. This ID is also used for
   * referencing services linked to specific participants, such as baggage.
   *
   * @generated from field: int32 traveller_id = 1;
   */
  travellerId = 0;

  /**
   * Gender, as defined by the enum below.
   *
   * @generated from field: cmp.types.v3.GenderType gender = 2;
   */
  gender = GenderType.UNSPECIFIED;

  /**
   * Many systems use a single field each for all first names and surnames.
   * However, many countries have multiple given names and family names, and certain
   * authorities require the names to be registered exactly as they appear in the
   * traveller's passport.
   * 
   * For example, a traveller might have "Diana Frances" as the first name and
   * "Spencer" as the surname, or "Winnie" as the first name and "Madikizela-Mandela"
   * as the surname (i.e. a double-barrelled surname). In Spanish naming traditions,
   * it is common to have two surnames: one from the father and one from the mother,
   * as in "Julio Iglesias de la Cueva" and "Enrique Iglesias Preysler". To handle
   * these variations, multiple entries are allowed. Systems with a fixed number of
   * fields may use the first entry for one component and the second entry for the other.
   * For example for full name "John Roger Stephens Legend":
   *    first_names: ["John",  "Roger"]
   *    surnames: ["Stephens", "Legend"]
   *
   * @generated from field: repeated string first_names = 3;
   */
  firstNames: string[] = [];

  /**
   * @generated from field: repeated string surnames = 4;
   */
  surnames: string[] = [];

  /**
   * @generated from field: cmp.types.v2.ContactInfo contact_info = 5;
   */
  contactInfo?: ContactInfo;

  /**
   * @generated from field: repeated cmp.types.v1.Document documents = 6;
   */
  documents: Document[] = [];

  constructor(data?: PartialMessage<ExtensiveTraveller>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.ExtensiveTraveller";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "traveller_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "gender", kind: "enum", T: proto3.getEnumType(GenderType) },
    { no: 3, name: "first_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "surnames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "contact_info", kind: "message", T: ContactInfo },
    { no: 6, name: "documents", kind: "message", T: Document, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromJsonString(jsonString, options);
  }

  static equals(a: ExtensiveTraveller | PlainMessage<ExtensiveTraveller> | undefined, b: ExtensiveTraveller | PlainMessage<ExtensiveTraveller> | undefined): boolean {
    return proto3.util.equals(ExtensiveTraveller, a, b);
  }
}

/**
 * Extra info about the traveller or someone related
 *
 * @generated from message cmp.types.v3.TravellerExtraInfo
 */
export class TravellerExtraInfo extends Message<TravellerExtraInfo> {
  /**
   * Traveller
   *
   * @generated from field: cmp.types.v3.BasicTraveller basic_traveller = 1;
   */
  basicTraveller?: BasicTraveller;

  /**
   * Traveller first names
   *
   * @generated from field: repeated string first_names = 2;
   */
  firstNames: string[] = [];

  /**
   * Traveller surnames
   *
   * @generated from field: repeated string surnames = 3;
   */
  surnames: string[] = [];

  /**
   * Relationship with the traveller
   *
   * @generated from field: cmp.types.v3.TravellerRelationship relationship_to_traveller = 4;
   */
  relationshipToTraveller = TravellerRelationship.UNSPECIFIED;

  constructor(data?: PartialMessage<TravellerExtraInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.TravellerExtraInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "basic_traveller", kind: "message", T: BasicTraveller },
    { no: 2, name: "first_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "surnames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "relationship_to_traveller", kind: "enum", T: proto3.getEnumType(TravellerRelationship) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TravellerExtraInfo {
    return new TravellerExtraInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TravellerExtraInfo {
    return new TravellerExtraInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TravellerExtraInfo {
    return new TravellerExtraInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TravellerExtraInfo | PlainMessage<TravellerExtraInfo> | undefined, b: TravellerExtraInfo | PlainMessage<TravellerExtraInfo> | undefined): boolean {
    return proto3.util.equals(TravellerExtraInfo, a, b);
  }
}

