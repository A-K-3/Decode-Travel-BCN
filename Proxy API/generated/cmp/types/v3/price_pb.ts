// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v3/price.proto (package cmp.types.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { PriceBreakdownType } from "../v1/price_type_pb";
import { Currency } from "./currency_pb";

/**
 * ### PriceDetail
 * 
 * This message consists of the value as a Price object and additional fields as
 * binding, concept, and breakdown.
 * 
 * Breakdown is a recursively inherited object of PriceDetail. This way complex
 * pricing structures can be represented.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/price.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v3/price.proto.dot.svg)
 *
 * @generated from message cmp.types.v3.PriceDetail
 */
export class PriceDetail extends Message<PriceDetail> {
  /**
   * Principle price element
   *
   * @generated from field: cmp.types.v3.Price price = 1;
   */
  price?: Price;

  /**
   * Identification whether the price must be respected towards the end-user
   * and the product or service cannot be offered for a lower price.
   *
   * @generated from field: bool binding = 2;
   */
  binding = false;

  /**
   * Description of the product or service this price(element) is valid for.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * If not specified, the default of the boolean is false which means it is
   * included in the price. If set to True, it means that this PriceDetail is only
   * payable locally. For example local tourism tax that you pay at the reception of
   * a hotel. Intended to be used in the breakdown.
   *
   * @generated from field: bool locally_payable = 4;
   */
  locallyPayable = false;

  /**
   * Type of price breakdown. This is meant to be used in price breakdown
   * definitions, when we want to specify the different elements of how a total
   * price was computed.
   *
   * @generated from field: cmp.types.v1.PriceBreakdownType type = 5;
   */
  type?: PriceBreakdownType;

  /**
   * We can use a single PriceDetail to represent a price breakdown.
   *
   * @generated from field: repeated cmp.types.v3.PriceDetail breakdowns = 6;
   */
  breakdowns: PriceDetail[] = [];

  constructor(data?: PartialMessage<PriceDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.PriceDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "message", T: Price },
    { no: 2, name: "binding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "locally_payable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "type", kind: "message", T: PriceBreakdownType },
    { no: 6, name: "breakdowns", kind: "message", T: PriceDetail, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceDetail {
    return new PriceDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJsonString(jsonString, options);
  }

  static equals(a: PriceDetail | PlainMessage<PriceDetail> | undefined, b: PriceDetail | PlainMessage<PriceDetail> | undefined): boolean {
    return proto3.util.equals(PriceDetail, a, b);
  }
}

/**
 * ### Simple Price type message Price
 * 
 * Value of the price, represented as an integer converted to string.
 * 
 * This field is intentionally a string. Since currency can be cryptocurrency
 * with up to 18 decimal places precision, we need a reliable way to represent
 * large integers without precision loss.
 * 
 * Definition of the price message: The combination of "value" and "decimals" fields
 * always expresses the value of the currency itself, not its smallest fraction
 * (e.g., ETH not wei, CAM not aCAM, BTC not Satoshi, EUR not EUR-Cents).
 * Partners should avoid rounding with cryptocurrencies.
 * 
 * Example implementations:
 * 
 * Off-chain payment of 100 â‚¬ or 100 $:
 * value=10000, decimals=2, iso_currency=EUR or USD
 * 
 * On-chain payment of 100.65 EURSH:
 * value=10065, decimals=2, contract_address=0x...
 * This currency has 5 decimals on Columbus and Camino. To create the transaction value,
 * 10065 must be divided by 10^2 = 100.65 EURSH, then represented in its smallest
 * fraction by multiplying 100.65 EURSH * 10^5 => 10065000
 * (Example conversion to bigint without losing accuracy: bigint(10065) * 10^(5-2))
 * 
 * On-chain payment of 0.0065 BTC:
 * value=65, decimals=4, contract_address=0x...
 * Using the contract address, we retrieve the decimals and currency name: 8 decimals & WBTC
 * With 4 decimals specified in the message, we divide 65 by 10^4 == 0.0065 WBTC
 * (for display in UIs)
 * 
 * For on-chain operations, this value must be converted to its smallest unit as:
 * bigint(65) * 10^(8-4) == 650000
 * 
 * On-chain payment of 1 nCAM:
 * value=1, decimals=9
 * This currency has denominator 18 on Columbus and Camino. To mint 1 nCam, it must be
 * divided by 10^9 = The currency has denominator 18 on
 * Columbus. To mint 1 nCam, divide by 10^9 = 0.000000001 CAM, then express in its
 * smallest fraction by multiplying 0.000000001 * 10^18 => 1000000000 aCAM
 * 
 * For the "currency" field, the Currency message provides a "one-of" option to specify:
 * - Traditional fiat currency (EUR, USD, CHF) according to ISO codes
 * - Native Camino and Columbus blockchain currency (CAM)
 * - ERC20 digital currencies like stablecoins (EURe, EURSH, EURC, USDC), Volatile
 *   coins (BTC, AVAX) and Loyalty points (Aventus/AVT for events, Plutus/PLU from
 *   Visa, AVA from Travala, Blackbird's FLY)
 * 
 * The value of loyalty points must be verifiable or agreed between partners.
 * Partial payment combining loyalty points with fiat or ERC20 currencies in a
 * single transaction is not yet implemented.
 * 
 * As a Distributor, look up the configured currencies your Suppliers support
 * in their CM Account configuration. For ERC20 currencies or loyalty points,
 * the EVM contract address must be supplied in the Search Request. This address
 * can be found in the Supplier's CM account and must be verified as authentic.
 * 
 * Distributors must acquire necessary funds and transfer them to their CM Account
 * for on-chain payments.
 * 
 * Suppliers verify the received currency in the search request and, if supported,
 * process the request to respond in the requested currency. If the currency is
 * not recognized or supported, an error is returned.
 * 
 * Partner Plugins for both Distributors and Suppliers should be able to map
 * CAM or other digital currencies with EVM Contract addresses to their respective
 * currency entities in the back office system.
 *
 * @generated from message cmp.types.v3.Price
 */
export class Price extends Message<Price> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  /**
   * @generated from field: int32 decimals = 2;
   */
  decimals = 0;

  /**
   * @generated from field: cmp.types.v3.Currency currency = 3;
   */
  currency?: Currency;

  constructor(data?: PartialMessage<Price>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v3.Price";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "currency", kind: "message", T: Currency },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Price {
    return new Price().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJsonString(jsonString, options);
  }

  static equals(a: Price | PlainMessage<Price> | undefined, b: Price | PlainMessage<Price> | undefined): boolean {
    return proto3.util.equals(Price, a, b);
  }
}

