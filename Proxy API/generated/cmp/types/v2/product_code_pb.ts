// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v2/product_code.proto (package cmp.types.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Product Code type
 *
 * @generated from enum cmp.types.v2.ProductCodeType
 */
export enum ProductCodeType {
  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_GIATA = 1;
   */
  GIATA = 1,

  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_GOAL_ID = 2;
   */
  GOAL_ID = 2,

  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_IATA = 3;
   */
  IATA = 3,

  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_ICAO = 4;
   */
  ICAO = 4,

  /**
   * @generated from enum value: PRODUCT_CODE_TYPE_SUPPLIER = 5;
   */
  SUPPLIER = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ProductCodeType)
proto3.util.setEnumType(ProductCodeType, "cmp.types.v2.ProductCodeType", [
  { no: 0, name: "PRODUCT_CODE_TYPE_UNSPECIFIED" },
  { no: 1, name: "PRODUCT_CODE_TYPE_GIATA" },
  { no: 2, name: "PRODUCT_CODE_TYPE_GOAL_ID" },
  { no: 3, name: "PRODUCT_CODE_TYPE_IATA" },
  { no: 4, name: "PRODUCT_CODE_TYPE_ICAO" },
  { no: 5, name: "PRODUCT_CODE_TYPE_SUPPLIER" },
]);

/**
 * Product code and type
 * 
 * This is being used in requests to specify the a list of products to be included in the reponse
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/product_code.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/product_code.proto.dot.svg)
 *
 * @generated from message cmp.types.v2.ProductCode
 */
export class ProductCode extends Message<ProductCode> {
  /**
   * In most cases like in accommodation, just the field "code" and "type" will be
   * used. For example in case of a GiataID (for example code=182568), a provider
   * hotel code (for example a hotel code=AESPMI1234), a transfer code, etc.
   * However, for flight and train it is common to have a code and a number like "EW
   * 51" or "ICE 2803", which would then be code=EW and number=51 or code=ICE and
   * number=2803. It is not recommended to concatenate for example the airline code
   * and the flight number into the code field as "EW 51", as this would cause different
   * implementations for providers of the same product.
   * 
   * Please note that when utilizing licensed codes or formats such as GiataID and DRV
   * GlobalTypes, it is the partners' responsibility to confirm and settle any associated
   * license fees directly with the respective organizations
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * @generated from field: int32 number = 2;
   */
  number = 0;

  /**
   * @generated from field: cmp.types.v2.ProductCodeType type = 3;
   */
  type = ProductCodeType.UNSPECIFIED;

  constructor(data?: PartialMessage<ProductCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.ProductCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(ProductCodeType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProductCode {
    return new ProductCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProductCode {
    return new ProductCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProductCode {
    return new ProductCode().fromJsonString(jsonString, options);
  }

  static equals(a: ProductCode | PlainMessage<ProductCode> | undefined, b: ProductCode | PlainMessage<ProductCode> | undefined): boolean {
    return proto3.util.equals(ProductCode, a, b);
  }
}

/**
 * @generated from message cmp.types.v2.SupplierProductCode
 */
export class SupplierProductCode extends Message<SupplierProductCode> {
  /**
   * The supplier product code is unique for a product provided by the supplier and it
   * must remain consistent across the different messages like the ProductList, ProductInfo
   * and Search messages. Mapping is done on static data, however making a search request
   * with a GiataID or an ICAO code, could return one or more search results with each
   * individual supplier codes in case the code type is not unique and the supplier has
   * multiple products for the requested code. An example could be making a request for an
   * accommodation with a GiataID and the supplier can offer a product with just the hotel,
   * the hotel with a ski pass or the hotel with a rent a car. For packages we can imagine
   * an accommodation, the accommodation with a flight and transfer or the accommodation with
   * a flight and a rent a car. As the product descriptions from the supplier will have
   * different services, it is safe to assume the product codes will be differnt, the product
   * name will be different and the descriptions and amenities as well in the ProductList and
   * ProductInfo messages.
   *
   * @generated from field: string supplier_code = 1;
   */
  supplierCode = "";

  /**
   * @generated from field: int32 supplier_number = 2;
   */
  supplierNumber = 0;

  constructor(data?: PartialMessage<SupplierProductCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.SupplierProductCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supplier_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "supplier_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SupplierProductCode {
    return new SupplierProductCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SupplierProductCode {
    return new SupplierProductCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SupplierProductCode {
    return new SupplierProductCode().fromJsonString(jsonString, options);
  }

  static equals(a: SupplierProductCode | PlainMessage<SupplierProductCode> | undefined, b: SupplierProductCode | PlainMessage<SupplierProductCode> | undefined): boolean {
    return proto3.util.equals(SupplierProductCode, a, b);
  }
}

