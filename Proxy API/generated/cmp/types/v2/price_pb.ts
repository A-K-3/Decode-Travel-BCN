// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v2/price.proto (package cmp.types.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { PriceBreakdownType } from "../v1/price_type_pb";
import { Currency } from "./currency_pb";

/**
 * ### PriceDetail
 * 
 * This message consists of the value as a Price object and additional fields as
 * binding, concept, and breakdown.
 * 
 * Breakdown is a recursively inherited object of PriceDetail. This way complex
 * pricing structures can be represented.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/price.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/price.proto.dot.svg)
 *
 * @generated from message cmp.types.v2.PriceDetail
 */
export class PriceDetail extends Message<PriceDetail> {
  /**
   * Principle price element
   *
   * @generated from field: cmp.types.v2.Price price = 1;
   */
  price?: Price;

  /**
   * Identification whether the price must be respected towards the end-user
   * and the product or service cannot be offered for a lower price.
   *
   * @generated from field: bool binding = 2;
   */
  binding = false;

  /**
   * Description of the product or service this price(element) is valid for.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * If not specified, the default of the boolean is false which means it is
   * included in the price. If set to True, it means that this PriceDetail is only
   * payable locally. For example local tourism tax that you pay at the reception of
   * a hotel. Intended to be used in the breakdown.
   *
   * @generated from field: bool locally_payable = 4;
   */
  locallyPayable = false;

  /**
   * Type of price breakdown. This is meant to be used in price breakdown
   * definitions, when we want to specify the different elements of how a total
   * price was computed.
   *
   * @generated from field: cmp.types.v1.PriceBreakdownType type = 5;
   */
  type?: PriceBreakdownType;

  /**
   * We can use a single PriceDetail to represent a price breakdown.
   *
   * @generated from field: repeated cmp.types.v2.PriceDetail breakdowns = 6;
   */
  breakdowns: PriceDetail[] = [];

  constructor(data?: PartialMessage<PriceDetail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.PriceDetail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "message", T: Price },
    { no: 2, name: "binding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "locally_payable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "type", kind: "message", T: PriceBreakdownType },
    { no: 6, name: "breakdowns", kind: "message", T: PriceDetail, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriceDetail {
    return new PriceDetail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriceDetail {
    return new PriceDetail().fromJsonString(jsonString, options);
  }

  static equals(a: PriceDetail | PlainMessage<PriceDetail> | undefined, b: PriceDetail | PlainMessage<PriceDetail> | undefined): boolean {
    return proto3.util.equals(PriceDetail, a, b);
  }
}

/**
 * ### Simple Price type message Price
 * 
 * Value of the price, this should be an integer converted to string.
 * 
 * This field is a string intentionally. Because the currency can be a crypto
 * currency, we need a reliable way to represent big integers as most of the crypto
 * currencies have 18 decimals precision.
 * 
 * Definition of the price message: The combination of "value" and "decimals" fields
 * express always the value of the currency, not of the fraction of the currency [
 * ETH not wei, CAM and not aCAM, BTC and not Satoshi, EUR not EUR-Cents ] Be aware
 * that partners should not do rounding with crypto currencies.
 * 
 * Example implementations: off-chain payment of 100 â‚¬ or 100 $: value=10000
 * decimals=2 iso_currency=EUR or USD
 * 
 * On-chain payment of 100.65 EURSH value=10065 decimals=2 contract_address=0x...
 *  this currency has 5 decimals on Columbus and conclusively to create the
 *  transaction value, 10065 must be divided by 10^2 = 100.65 EURSH and created in
 *  its smallest fraction by multiplying  100.65 EURSH * 10^5 => 10065000 (example
 *  conversion to bigint without losing accuracy: bigint(10065) * 10^(5-2))
 * 
 * On-chain payment of 0.0065 BTC value=65 decimals=4 contract_address=0x... Using
 *  the contract address, we get the decimals decimals and the currency name or
 *  abbreviation: 8 decimals & WBTC Because we see 4 decimals specified in the
 *  message we divide 65 by 10^4 == 0.0065 WBTC (for showing in the front-end UIs)
 * 
 *  This currency has 8 decimals on-chain and conclusively to use the value of
 *  0.0065 for on-chain operations must be converted to big integer as bigint(65) *
 *  10^(8-4) == 650000
 * 
 * On-chain payment of 1 nCAM value=1 decimals=9 this currency has denominator 18 on
 *  Columbus and conclusively to mint the value of 1 nCam must be divided by 10^9 =
 *  0.000000001 CAM and minted in its smallest fraction by multiplying 0.000000001 *
 *  10^18 => 1000000000 aCAM
 *
 * @generated from message cmp.types.v2.Price
 */
export class Price extends Message<Price> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  /**
   * @generated from field: int32 decimals = 2;
   */
  decimals = 0;

  /**
   * @generated from field: cmp.types.v2.Currency currency = 3;
   */
  currency?: Currency;

  constructor(data?: PartialMessage<Price>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.Price";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "currency", kind: "message", T: Currency },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Price {
    return new Price().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJsonString(jsonString, options);
  }

  static equals(a: Price | PlainMessage<Price> | undefined, b: Price | PlainMessage<Price> | undefined): boolean {
    return proto3.util.equals(Price, a, b);
  }
}

