// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/types/v2/traveller.proto (package cmp.types.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Date } from "../v1/date_pb";
import { Country } from "./country_pb";
import { ContactInfo } from "./contact_info_pb";
import { Document } from "../v1/document_pb";

/**
 * Traveller Type
 *
 * @generated from enum cmp.types.v2.TravellerType
 */
export enum TravellerType {
  /**
   * @generated from enum value: TRAVELLER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TRAVELLER_TYPE_ADULT = 1;
   */
  ADULT = 1,

  /**
   * @generated from enum value: TRAVELLER_TYPE_CHILD = 2;
   */
  CHILD = 2,

  /**
   * @generated from enum value: TRAVELLER_TYPE_INFANT = 3;
   */
  INFANT = 3,

  /**
   * @generated from enum value: TRAVELLER_TYPE_SENIOR = 4;
   */
  SENIOR = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TravellerType)
proto3.util.setEnumType(TravellerType, "cmp.types.v2.TravellerType", [
  { no: 0, name: "TRAVELLER_TYPE_UNSPECIFIED" },
  { no: 1, name: "TRAVELLER_TYPE_ADULT" },
  { no: 2, name: "TRAVELLER_TYPE_CHILD" },
  { no: 3, name: "TRAVELLER_TYPE_INFANT" },
  { no: 4, name: "TRAVELLER_TYPE_SENIOR" },
]);

/**
 * Gender Type
 *
 * @generated from enum cmp.types.v2.GenderType
 */
export enum GenderType {
  /**
   * @generated from enum value: GENDER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: GENDER_TYPE_MALE = 1;
   */
  MALE = 1,

  /**
   * @generated from enum value: GENDER_TYPE_FEMALE = 2;
   */
  FEMALE = 2,

  /**
   * @generated from enum value: GENDER_TYPE_NONBINARY = 3;
   */
  NONBINARY = 3,

  /**
   * @generated from enum value: GENDER_TYPE_AGENDER = 4;
   */
  AGENDER = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(GenderType)
proto3.util.setEnumType(GenderType, "cmp.types.v2.GenderType", [
  { no: 0, name: "GENDER_TYPE_UNSPECIFIED" },
  { no: 1, name: "GENDER_TYPE_MALE" },
  { no: 2, name: "GENDER_TYPE_FEMALE" },
  { no: 3, name: "GENDER_TYPE_NONBINARY" },
  { no: 4, name: "GENDER_TYPE_AGENDER" },
]);

/**
 * Traveller
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/traveller.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v2/traveller.proto.dot.svg)
 *
 * @generated from message cmp.types.v2.BasicTraveller
 */
export class BasicTraveller extends Message<BasicTraveller> {
  /**
   * Guest number, the lowest number is the lead-pax. This ID is also used for
   * referencing services linked to specific participants, like baggage.
   * the traveller_id must be kept consistent between the search request and response.
   * Conclusively if the request specifies traveller 0 and 1, then the response also refers
   * to these traveller numbers. If the request specifies 1 and 2 or 10 and 20, then the
   * response also returns these references.
   * The traveller_id is specified in each unit and only detailed once in the search response
   * repeated travellers field
   *
   * @generated from field: int32 traveller_id = 1;
   */
  travellerId = 0;

  /**
   * Traveller type from enum below
   *
   * @generated from field: cmp.types.v2.TravellerType type = 2;
   */
  type = TravellerType.UNSPECIFIED;

  /**
   * Birthdate
   *
   * @generated from field: cmp.types.v1.Date birthdate = 3;
   */
  birthdate?: Date;

  /**
   * The country code for the nationality of the traveller.
   *
   * @generated from field: cmp.types.v2.Country nationality = 4;
   */
  nationality = Country.UNSPECIFIED;

  constructor(data?: PartialMessage<BasicTraveller>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.BasicTraveller";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "traveller_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TravellerType) },
    { no: 3, name: "birthdate", kind: "message", T: Date },
    { no: 4, name: "nationality", kind: "enum", T: proto3.getEnumType(Country) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicTraveller {
    return new BasicTraveller().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicTraveller {
    return new BasicTraveller().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicTraveller {
    return new BasicTraveller().fromJsonString(jsonString, options);
  }

  static equals(a: BasicTraveller | PlainMessage<BasicTraveller> | undefined, b: BasicTraveller | PlainMessage<BasicTraveller> | undefined): boolean {
    return proto3.util.equals(BasicTraveller, a, b);
  }
}

/**
 * @generated from message cmp.types.v2.ExtensiveTraveller
 */
export class ExtensiveTraveller extends Message<ExtensiveTraveller> {
  /**
   * Guest number. The lowest number is the lead-pax. This ID is also used for
   * referencing services linked to specific participants, such as baggage.
   *
   * @generated from field: int32 traveller_id = 1;
   */
  travellerId = 0;

  /**
   * Gender, as defined by the enum below.
   *
   * @generated from field: cmp.types.v2.GenderType gender = 2;
   */
  gender = GenderType.UNSPECIFIED;

  /**
   * Many systems use a single field each for all first names and surnames.
   * However, many countries have multiple given names and family names, and certain
   * authorities require the names to be registered exactly as they appear in the
   * traveller's passport.
   * 
   * For example, a traveller might have "Diana Frances" as the first name and
   * "Spencer" as the surname, or "Winnie" as the first name and "Madikizela-Mandela"
   * as the surname (i.e. a double-barrelled surname). In Spanish naming traditions,
   * it is common to have two surnames: one from the father and one from the mother,
   * as in "Julio Iglesias de la Cueva" and "Enrique Iglesias Preysler". To handle
   * these variations, multiple entries are allowed. Systems with a fixed number of
   * fields may use the first entry for one component and the second entry for the other.
   * For example:
   *    first_names: ["John",  "Roger"]
   *    surnames: ["Stephens", "Legend"]
   *
   * @generated from field: repeated string first_names = 3;
   */
  firstNames: string[] = [];

  /**
   * @generated from field: repeated string surnames = 4;
   */
  surnames: string[] = [];

  /**
   * @generated from field: cmp.types.v2.ContactInfo contact_info = 5;
   */
  contactInfo?: ContactInfo;

  /**
   * @generated from field: repeated cmp.types.v1.Document documents = 6;
   */
  documents: Document[] = [];

  constructor(data?: PartialMessage<ExtensiveTraveller>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.types.v2.ExtensiveTraveller";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "traveller_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "gender", kind: "enum", T: proto3.getEnumType(GenderType) },
    { no: 3, name: "first_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "surnames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "contact_info", kind: "message", T: ContactInfo },
    { no: 6, name: "documents", kind: "message", T: Document, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensiveTraveller {
    return new ExtensiveTraveller().fromJsonString(jsonString, options);
  }

  static equals(a: ExtensiveTraveller | PlainMessage<ExtensiveTraveller> | undefined, b: ExtensiveTraveller | PlainMessage<ExtensiveTraveller> | undefined): boolean {
    return proto3.util.equals(ExtensiveTraveller, a, b);
  }
}

