// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/seat_map/v4/availability.proto (package cmp.services.seat_map.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// ## SeatMap and SeatMapAvailability Services
//
// The SeatMap and SeatMapAvailability services are used to manage and retrieve
// seat map information and availability for various products, such as flights,
// trains, cruises and venues for activities like an opera, a concert or a sports
// event.
//
// ### SeatMap general information
//
// For smaller applications, such as an airplane, a small concert hall, or an
// intimate venue, a single, detailed SeatMap is often the most practical choice.
// In these cases, the entire seating arrangement can be presented clearly in one
// view without overwhelming the user.
// A unified map allows passengers or attendees to see exactly where their seat is
// in relation to entrances, aisles, or the focal point—whether that’s a stage, a
// screen, or the plane’s layout. Sections can still be used for example for business
// class or economy class, but the overall map remains relatively small and easy to
// process.
//
// In larger settings like stadiums or convention centers, however, a single
// detailed map can become overly dense and hard to process due to sheer size.
// That’s where multiple smaller SeatMaps, grouped by key areas, categories or
// products, can prove more effective.
//
// By focusing each map on specific zones—such as VIP, general admission, or
// seating blocks can more quickly filter down to the type of product they’re
// seeking.
//
// Still, both strategies have their strengths and trade-offs, which is why a
// hybrid approach often offers the best balance.
// This model starts with a single high-level map that shows the full venue at a
// glance, then allows users to zoom into specific sections for finer detail,
// using a different seat map, instead of drilling down into a subsection of a
// single seat map.
//
// ### SeatMap Service
//
// The SeatMap service is meant to be used as a static data service in combination
// with the SeatMapID of a product. Multiple SeatMaps can be linked to one
// product as a one specific flight might be operated with different planes on
// different days. However, a SeatMapID in a search result can only be one as the
// bookable option is one specific product such as a first class coupe in a train,
// or the VIP area of a concert.
//
// The SeatMap is stored in the distribution system and downloaded only once from
// the supplier for a multitude of displays on the distribution side.
//
// The SeatMapRequest requires a SeatMapID, which should be provided in the ProductInfo
// message for each product and should be downloaded once the product is firstly
// taken on-sale or when the product description id updated. It is multilingual for
// the seat amenities and features.
//
// A section can contain features and amenities, valid for all seats in that section.
// And a section holds either a SeatMapList detailing all seats or just a count of
// "seats", often used for unallocated sections like a standing area at a concert.
// Sections can be nested as many times as required and each section has its own image.
//
// ### SeatMapAvailability Service
//
// The SeatMapAvailability service is used to retrieve the availability of seats based
// on either the Search result_id or the Mint ID. This indicates a specific product for
// a specific date and time, such as a flight or a concert. Conclusively the supplier
// knows what SeatMapID to use and the availability of each seat (in case of a section
// with a SeatMapList) or how many seats are available in an unallocated section.
//
// For allocated sections, the SeatMapAvailability service returns a list of all
// available seats. Missing seats are already booked or reserved.
// The SeatMapAvailabilityResponse also allows nested sections, which can be used in
// case multiple sub sections each have their own SeatMapList.

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ErrorResponseHeader, RequestHeader, SuccessResponseHeader } from "../../../types/v4/common_pb";
import { UUID } from "../../../types/v4/uuid_pb";
import { SearchResultIdentifier } from "../../../types/v4/search_pb";
import { SeatMapInventory } from "../../../types/v4/seat_map_pb";

/**
 * Request for seat map availability data
 * 
 * Requests the seat map availability data for a given map ID
 *
 * @generated from message cmp.services.seat_map.v4.SeatMapAvailabilityRequest
 */
export class SeatMapAvailabilityRequest extends Message<SeatMapAvailabilityRequest> {
  /**
   * Message header
   * 
   * Header contains information about the request
   *
   * @generated from field: cmp.types.v4.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Required. The identifier of the seat map.
   *
   * @generated from oneof cmp.services.seat_map.v4.SeatMapAvailabilityRequest.identifier
   */
  identifier: {
    /**
     * Mint Identifier
     * 
     * Example: For flights which book before seat selection. In this case, the
     * buyer already have a `mint_id` because the service is already booked (minted
     * on-chain).
     *
     * @generated from field: cmp.types.v4.UUID mint_id = 2;
     */
    value: UUID;
    case: "mintId";
  } | {
    /**
     * Search result identifier with `search_id` & `result_id`
     * 
     * Example: For requesting seat availability for search results. In this case,
     * booking has not happened yet.
     *
     * @generated from field: cmp.types.v4.SearchResultIdentifier search_result_identifier = 3;
     */
    value: SearchResultIdentifier;
    case: "searchResultIdentifier";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SeatMapAvailabilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.seat_map.v4.SeatMapAvailabilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "mint_id", kind: "message", T: UUID, oneof: "identifier" },
    { no: 3, name: "search_result_identifier", kind: "message", T: SearchResultIdentifier, oneof: "identifier" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapAvailabilityRequest {
    return new SeatMapAvailabilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapAvailabilityRequest {
    return new SeatMapAvailabilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapAvailabilityRequest {
    return new SeatMapAvailabilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapAvailabilityRequest | PlainMessage<SeatMapAvailabilityRequest> | undefined, b: SeatMapAvailabilityRequest | PlainMessage<SeatMapAvailabilityRequest> | undefined): boolean {
    return proto3.util.equals(SeatMapAvailabilityRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.seat_map.v4.SeatMapAvailabilitySuccessResponse
 */
export class SeatMapAvailabilitySuccessResponse extends Message<SeatMapAvailabilitySuccessResponse> {
  /**
   * Message header
   * 
   * Header contains information about the response
   *
   * @generated from field: cmp.types.v4.SuccessResponseHeader header = 1;
   */
  header?: SuccessResponseHeader;

  /**
   * Required. Seat map availability data.
   *
   * @generated from field: cmp.types.v4.SeatMapInventory seat_map = 2;
   */
  seatMap?: SeatMapInventory;

  constructor(data?: PartialMessage<SeatMapAvailabilitySuccessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.seat_map.v4.SeatMapAvailabilitySuccessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: SuccessResponseHeader },
    { no: 2, name: "seat_map", kind: "message", T: SeatMapInventory },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapAvailabilitySuccessResponse {
    return new SeatMapAvailabilitySuccessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapAvailabilitySuccessResponse {
    return new SeatMapAvailabilitySuccessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapAvailabilitySuccessResponse {
    return new SeatMapAvailabilitySuccessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapAvailabilitySuccessResponse | PlainMessage<SeatMapAvailabilitySuccessResponse> | undefined, b: SeatMapAvailabilitySuccessResponse | PlainMessage<SeatMapAvailabilitySuccessResponse> | undefined): boolean {
    return proto3.util.equals(SeatMapAvailabilitySuccessResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.seat_map.v4.SeatMapAvailabilityErrorResponse
 */
export class SeatMapAvailabilityErrorResponse extends Message<SeatMapAvailabilityErrorResponse> {
  /**
   * Common error response header used in every error response.
   *
   * @generated from field: cmp.types.v4.ErrorResponseHeader header = 1;
   */
  header?: ErrorResponseHeader;

  constructor(data?: PartialMessage<SeatMapAvailabilityErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.seat_map.v4.SeatMapAvailabilityErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ErrorResponseHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapAvailabilityErrorResponse {
    return new SeatMapAvailabilityErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapAvailabilityErrorResponse {
    return new SeatMapAvailabilityErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapAvailabilityErrorResponse {
    return new SeatMapAvailabilityErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapAvailabilityErrorResponse | PlainMessage<SeatMapAvailabilityErrorResponse> | undefined, b: SeatMapAvailabilityErrorResponse | PlainMessage<SeatMapAvailabilityErrorResponse> | undefined): boolean {
    return proto3.util.equals(SeatMapAvailabilityErrorResponse, a, b);
  }
}

/**
 * Response for seat map availability request
 * 
 * Contains the seat map availability data for a given map ID
 *
 * @generated from message cmp.services.seat_map.v4.SeatMapAvailabilityResponse
 */
export class SeatMapAvailabilityResponse extends Message<SeatMapAvailabilityResponse> {
  /**
   * @generated from oneof cmp.services.seat_map.v4.SeatMapAvailabilityResponse.response
   */
  response: {
    /**
     * @generated from field: cmp.services.seat_map.v4.SeatMapAvailabilitySuccessResponse success_response = 1;
     */
    value: SeatMapAvailabilitySuccessResponse;
    case: "successResponse";
  } | {
    /**
     * @generated from field: cmp.services.seat_map.v4.SeatMapAvailabilityErrorResponse error_response = 2;
     */
    value: SeatMapAvailabilityErrorResponse;
    case: "errorResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SeatMapAvailabilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.seat_map.v4.SeatMapAvailabilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_response", kind: "message", T: SeatMapAvailabilitySuccessResponse, oneof: "response" },
    { no: 2, name: "error_response", kind: "message", T: SeatMapAvailabilityErrorResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeatMapAvailabilityResponse {
    return new SeatMapAvailabilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeatMapAvailabilityResponse {
    return new SeatMapAvailabilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeatMapAvailabilityResponse {
    return new SeatMapAvailabilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SeatMapAvailabilityResponse | PlainMessage<SeatMapAvailabilityResponse> | undefined, b: SeatMapAvailabilityResponse | PlainMessage<SeatMapAvailabilityResponse> | undefined): boolean {
    return proto3.util.equals(SeatMapAvailabilityResponse, a, b);
  }
}

