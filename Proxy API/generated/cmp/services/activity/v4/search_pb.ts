// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/activity/v4/search.proto (package cmp.services.activity.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// ### Activity Services
//
// The Activity services are used for both tickets and excursions.
//
// Any search message response in the Camino Messenger Protocol only includes
// dynamic data in the search, validate and mint process. Static data can be cached
// and kept up to date with the Product List and Product Details messages.
//
// Partners keep the list of activity products up-to-date on a daily basis, by
// getting changes since yesterday with the ActivityProductList service. The details
// of the updated activities are bing pulled using the ActivityProductInfo service.
//
// Once we have a traveller interested in an activity, the ActivitySearch service is
// used to obtain the pricing of relevant activities that are available. In this
// process there is no repeated exchange of static data to reduce the message size,
// reduce cost and increase processing speed.
//
// Similar to all other message types, the Activity service is constructed using the
// "Product", "Unit" and "Service" layers. For example the product is a Taylor Swift
// concert or a Disney World ticket. The unit then gives us a choice of the
// different options that are available, like for example a normal ticket or a VIP
// ticket. Finally we would have the services, which can be selected like do we go
// there by ourselves or is a transfer from our hotel included. This then would
// result to product=Disneyland, unit=VIP, service=TRFIncluded.
//
// It is of course impossible to offer a transfer from every hotel in Florida to
// Disney World. A supplier might have defined just the ticket, without transfer. And
// additionally a ticket with transfer from the 25 most popular hotels in the area.
// If the PickUp is not provided in the search request, the response should include
// an option without transfer and further options that include a transfer from
// several hotels that are close together and would cost the same for the ticket and
// transfer.
//
// The Activity search messages will be adapted to work with the SeatMap services,
// just like the Transport service. This package is **WIP**.

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ErrorResponseHeader, RequestHeader, SuccessResponseHeader } from "../../../types/v4/common_pb";
import { SearchParameters } from "../../../types/v4/search_pb";
import { ActivitySearchParameters } from "./search_parameters_types_pb";
import { TravelPeriod } from "../../../types/v4/travel_period_pb";
import { BasicTraveller } from "../../../types/v4/traveller_pb";
import { Coordinates, GeoCircle, GeoPolygon, GeoTree, LocationCodes } from "../../../types/v4/location_pb";
import { ExpiringUUID } from "../../../types/v4/uuid_pb";
import { ActivitySearchResult } from "./search_result_types_pb";

/**
 * Search request for Activities
 *
 * @generated from message cmp.services.activity.v4.ActivitySearchRequest
 */
export class ActivitySearchRequest extends Message<ActivitySearchRequest> {
  /**
   * Message header. Contains API version, message info string and end-user wallet
   * address.
   *
   * @generated from field: cmp.types.v4.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Generic search parameters
   * 
   * Ex: Inclusion of OnRequest options, inclusion of only the cheapest or all
   * options, setting the market, language, currency, sorting and filters etc.
   *
   * @generated from field: cmp.types.v4.SearchParameters search_parameters = 2;
   */
  searchParameters?: SearchParameters;

  /**
   * Activity specific search parameters
   * 
   * Here we set for example a list of activity product codes that we want to search
   * for, set min or mar duration or price.
   *
   * @generated from field: cmp.services.activity.v4.ActivitySearchParameters search_parameters_activity = 3;
   */
  searchParametersActivity?: ActivitySearchParameters;

  /**
   * Date range for when the activity will take place or be available
   *
   * @generated from field: cmp.types.v4.TravelPeriod travel_period = 4;
   */
  travelPeriod?: TravelPeriod;

  /**
   * Information about each person who will participate in the activity
   *
   * @generated from field: repeated cmp.types.v4.BasicTraveller travellers = 5;
   */
  travellers: BasicTraveller[] = [];

  /**
   * For search, set only one of the fields at once. Source location indicates the
   * customerâ€™s position at the start of the service. Typical value would be the
   * stay hotel or the touristic destination. The source location is needed for
   * service and transfer availability, pickup location and pickup time calculation.
   * Setting the source_location will reduce the list of options to the activities
   * that can be serviced. In the example of Disney World and Orlando it will reduce
   * the list substantially as the non-relevant pick-up points will not be included.
   * 
   * This one of field enforces only one of the fields below. They all share memory,
   * setting one will remove the others.
   *
   * @generated from oneof cmp.services.activity.v4.ActivitySearchRequest.source_location
   */
  sourceLocation: {
    /**
     * The code and code type of a stay location the provider will be able to process
     * Ex. GiataID
     *
     * @generated from field: cmp.types.v4.LocationCodes source_location_codes = 6;
     */
    value: LocationCodes;
    case: "sourceLocationCodes";
  } | {
    /**
     * Single geographic point represented by two double fields.
     *
     * @generated from field: cmp.types.v4.Coordinates source_location_coordinates = 7;
     */
    value: Coordinates;
    case: "sourceLocationCoordinates";
  } | {
    /**
     * Geo tree type, represented by Country, Region, and City_or_Resort.
     *
     * @generated from field: cmp.types.v4.GeoTree source_location_geo_tree = 8;
     */
    value: GeoTree;
    case: "sourceLocationGeoTree";
  } | {
    /**
     * Geo circle. Represented by a coordinate and a distance for radius
     *
     * @generated from field: cmp.types.v4.GeoCircle source_location_geo_circle = 9;
     */
    value: GeoCircle;
    case: "sourceLocationGeoCircle";
  } | {
    /**
     * Geo polygon. Represented by a list of coordinate points.
     *
     * @generated from field: cmp.types.v4.GeoPolygon source_location_geo_polygon = 10;
     */
    value: GeoPolygon;
    case: "sourceLocationGeoPolygon";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * For search, set only one of the field at once. Service location specifies the
   * areas involved in a ticket or excursion service. Service location indicates the
   * area of the requested services. Typical value would be the region or resort.
   * 
   * This one of field enforces only one of the fields below. They all share memory,
   * setting one will remove the others.
   *
   * @generated from oneof cmp.services.activity.v4.ActivitySearchRequest.service_location
   */
  serviceLocation: {
    /**
     * The code and code type of a stay location the distributor will be able to
     * process. Ex. Google Place ID, Foursquare fsq_id, OpenStreetMap Ref, Here ID or
     * any other agreed code type.
     *
     * @generated from field: cmp.types.v4.LocationCodes service_location_codes = 11;
     */
    value: LocationCodes;
    case: "serviceLocationCodes";
  } | {
    /**
     * Single geographic point represented by two double fields.
     *
     * @generated from field: cmp.types.v4.Coordinates service_location_coordinates = 12;
     */
    value: Coordinates;
    case: "serviceLocationCoordinates";
  } | {
    /**
     * Geo tree type, represented by Country, Region, and City_or_Resort.
     *
     * @generated from field: cmp.types.v4.GeoTree service_location_geo_tree = 13;
     */
    value: GeoTree;
    case: "serviceLocationGeoTree";
  } | {
    /**
     * Geo circle. Represented by a coordinate and a distance for radius
     *
     * @generated from field: cmp.types.v4.GeoCircle service_location_geo_circle = 14;
     */
    value: GeoCircle;
    case: "serviceLocationGeoCircle";
  } | {
    /**
     * Geo polygon. Represented by a list of coordinate points.
     *
     * @generated from field: cmp.types.v4.GeoPolygon service_location_geo_polygon = 15;
     */
    value: GeoPolygon;
    case: "serviceLocationGeoPolygon";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ActivitySearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v4.ActivitySearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "search_parameters", kind: "message", T: SearchParameters },
    { no: 3, name: "search_parameters_activity", kind: "message", T: ActivitySearchParameters },
    { no: 4, name: "travel_period", kind: "message", T: TravelPeriod },
    { no: 5, name: "travellers", kind: "message", T: BasicTraveller, repeated: true },
    { no: 6, name: "source_location_codes", kind: "message", T: LocationCodes, oneof: "source_location" },
    { no: 7, name: "source_location_coordinates", kind: "message", T: Coordinates, oneof: "source_location" },
    { no: 8, name: "source_location_geo_tree", kind: "message", T: GeoTree, oneof: "source_location" },
    { no: 9, name: "source_location_geo_circle", kind: "message", T: GeoCircle, oneof: "source_location" },
    { no: 10, name: "source_location_geo_polygon", kind: "message", T: GeoPolygon, oneof: "source_location" },
    { no: 11, name: "service_location_codes", kind: "message", T: LocationCodes, oneof: "service_location" },
    { no: 12, name: "service_location_coordinates", kind: "message", T: Coordinates, oneof: "service_location" },
    { no: 13, name: "service_location_geo_tree", kind: "message", T: GeoTree, oneof: "service_location" },
    { no: 14, name: "service_location_geo_circle", kind: "message", T: GeoCircle, oneof: "service_location" },
    { no: 15, name: "service_location_geo_polygon", kind: "message", T: GeoPolygon, oneof: "service_location" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchRequest | PlainMessage<ActivitySearchRequest> | undefined, b: ActivitySearchRequest | PlainMessage<ActivitySearchRequest> | undefined): boolean {
    return proto3.util.equals(ActivitySearchRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.activity.v4.ActivitySearchSuccessResponse
 */
export class ActivitySearchSuccessResponse extends Message<ActivitySearchSuccessResponse> {
  /**
   * Message header. Contains API version, message info string and end user wallet
   * address.
   *
   * @generated from field: cmp.types.v4.SuccessResponseHeader header = 1;
   */
  header?: SuccessResponseHeader;

  /**
   * Search_id to be used in subsequent requests like the "Validation Request".
   *
   * @generated from field: cmp.types.v4.ExpiringUUID search_id = 2;
   */
  searchId?: ExpiringUUID;

  /**
   * Unique combinations of bookable search results, each identified by a result_id
   * that needs to be carried through to the validate request.
   *
   * @generated from field: repeated cmp.services.activity.v4.ActivitySearchResult results = 3;
   */
  results: ActivitySearchResult[] = [];

  /**
   * Repeated travellers from the request. Used for validating the response.
   *
   * @generated from field: repeated cmp.types.v4.BasicTraveller travellers = 4;
   */
  travellers: BasicTraveller[] = [];

  constructor(data?: PartialMessage<ActivitySearchSuccessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v4.ActivitySearchSuccessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: SuccessResponseHeader },
    { no: 2, name: "search_id", kind: "message", T: ExpiringUUID },
    { no: 3, name: "results", kind: "message", T: ActivitySearchResult, repeated: true },
    { no: 4, name: "travellers", kind: "message", T: BasicTraveller, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchSuccessResponse {
    return new ActivitySearchSuccessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchSuccessResponse {
    return new ActivitySearchSuccessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchSuccessResponse {
    return new ActivitySearchSuccessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchSuccessResponse | PlainMessage<ActivitySearchSuccessResponse> | undefined, b: ActivitySearchSuccessResponse | PlainMessage<ActivitySearchSuccessResponse> | undefined): boolean {
    return proto3.util.equals(ActivitySearchSuccessResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.activity.v4.ActivitySearchErrorResponse
 */
export class ActivitySearchErrorResponse extends Message<ActivitySearchErrorResponse> {
  /**
   * Common error response header used in every error response.
   *
   * @generated from field: cmp.types.v4.ErrorResponseHeader header = 1;
   */
  header?: ErrorResponseHeader;

  constructor(data?: PartialMessage<ActivitySearchErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v4.ActivitySearchErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ErrorResponseHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchErrorResponse {
    return new ActivitySearchErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchErrorResponse {
    return new ActivitySearchErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchErrorResponse {
    return new ActivitySearchErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchErrorResponse | PlainMessage<ActivitySearchErrorResponse> | undefined, b: ActivitySearchErrorResponse | PlainMessage<ActivitySearchErrorResponse> | undefined): boolean {
    return proto3.util.equals(ActivitySearchErrorResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.activity.v4.ActivitySearchResponse
 */
export class ActivitySearchResponse extends Message<ActivitySearchResponse> {
  /**
   * @generated from oneof cmp.services.activity.v4.ActivitySearchResponse.response
   */
  response: {
    /**
     * @generated from field: cmp.services.activity.v4.ActivitySearchSuccessResponse success_response = 1;
     */
    value: ActivitySearchSuccessResponse;
    case: "successResponse";
  } | {
    /**
     * @generated from field: cmp.services.activity.v4.ActivitySearchErrorResponse error_response = 2;
     */
    value: ActivitySearchErrorResponse;
    case: "errorResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ActivitySearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v4.ActivitySearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_response", kind: "message", T: ActivitySearchSuccessResponse, oneof: "response" },
    { no: 2, name: "error_response", kind: "message", T: ActivitySearchErrorResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchResponse | PlainMessage<ActivitySearchResponse> | undefined, b: ActivitySearchResponse | PlainMessage<ActivitySearchResponse> | undefined): boolean {
    return proto3.util.equals(ActivitySearchResponse, a, b);
  }
}

