// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/activity/v3/search.proto (package cmp.services.activity.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// ### Activity Services
//
// The Activity services are used for both tickets and excursions.
//
// Any search message response in the Camino Messenger Protocol only includes
// dynamic data in the search, validate and mint process. Static data can be cached
// and kept up to date with the Product List and Product Details messages.
//
// Partners keep the list of activity products up-to-date on a daily basis, by
// getting changes since yesterday with the ActivityProductList service. The details
// of the updated activities are bing pulled using the ActivityProductInfo service.
//
// Once we have a traveller interested in an activity, the ActivitySearch service is
// used to obtain the pricing of relevant activities that are available. In this
// process there is no repeated exchange of static data to reduce the message size,
// reduce cost and increase processing speed.
//
// Similar to all other message types, the Activity service is constructed using the
// "Product", "Unit" and "Service" layers. For example the product is a Taylor Swift
// concert or a Disney World ticket. The unit then gives us a choice of the
// different options that are available, like for example a normal ticket or a VIP
// ticket. Finally we would have the services, which can be selected like do we go
// there by ourselves or is a transfer from our hotel included. This then would
// result to product=Disneyland, unit=VIP, service=TRFIncluded.
//
// It is of course impossible to offer a transfer from every hotel in Florida to
// Disney World. A supplier might have defined just the ticket, without transfer. And
// additionally a ticket with transfer from the 25 most popular hotels in the area.
// If the PickUp is not provided in the search request, the response should include
// an option without transfer and further options that include a transfer from
// several hotels that are close together and would cost the same for the ticket and
// transfer.
//
// The Activity search messages will be adapted to work with the SeatMap services,
// just like the Transport service. This package is **WIP**.

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { RequestHeader, ResponseHeader } from "../../../types/v1/common_pb";
import { SearchParameters, SearchRequestMetadata, SearchResponseMetadata } from "../../../types/v3/search_pb";
import { ActivitySearchParameters } from "./search_parameters_types_pb";
import { TravelPeriod } from "../../../types/v1/travel_period_pb";
import { BasicTraveller } from "../../../types/v3/traveller_pb";
import { Coordinates, GeoCircle, GeoPolygon, GeoTree, LocationCodes } from "../../../types/v2/location_pb";
import { ActivitySearchResult } from "./search_result_types_pb";

/**
 * Search request for Activities
 *
 * @generated from message cmp.services.activity.v3.ActivitySearchRequest
 */
export class ActivitySearchRequest extends Message<ActivitySearchRequest> {
  /**
   * Message header. Contains API version, message info string and end-user wallet
   * address.
   *
   * @generated from field: cmp.types.v1.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Search request metadata
   *
   * @generated from field: cmp.types.v3.SearchRequestMetadata metadata = 2;
   */
  metadata?: SearchRequestMetadata;

  /**
   * Generic search parameters
   * 
   * Ex: Inclusion of OnRequest options, inclusion of only the cheapest or all
   * options, setting the market, language, currency, sorting and filters etc.
   *
   * @generated from field: cmp.types.v3.SearchParameters search_parameters_generic = 3;
   */
  searchParametersGeneric?: SearchParameters;

  /**
   * Activity specific search parameters
   * 
   * Here we set for example a list of activity product codes that we want to search
   * for, set min or mar duration or price.
   *
   * @generated from field: cmp.services.activity.v3.ActivitySearchParameters search_parameters_activity = 4;
   */
  searchParametersActivity?: ActivitySearchParameters;

  /**
   * Travel period
   *
   * @generated from field: cmp.types.v1.TravelPeriod travel_period = 5;
   */
  travelPeriod?: TravelPeriod;

  /**
   * Travellers
   *
   * @generated from field: repeated cmp.types.v3.BasicTraveller travellers = 6;
   */
  travellers: BasicTraveller[] = [];

  /**
   * For search, set only one of the fields at once. Source location indicates the
   * customerâ€™s position at the start of the service. Typical value would be the
   * stay hotel or the touristic destination. The source location is needed for
   * service and transfer availability, pickup location and pickup time calculation.
   * Setting the source_location will reduce the list of options to the activities
   * that can be serviced. In the example of Disney World and Orlando it will reduce
   * the list substantially as the non-relevant pick-up points will not be included.
   * 
   * This one of field enforces only one of the fields below. They all share memory,
   * setting one will remove the others.
   *
   * @generated from oneof cmp.services.activity.v3.ActivitySearchRequest.source_location
   */
  sourceLocation: {
    /**
     * The code and code type of a stay location the provider will be able to process
     * Ex. GiataID
     *
     * @generated from field: cmp.types.v2.LocationCodes source_location_codes = 7;
     */
    value: LocationCodes;
    case: "sourceLocationCodes";
  } | {
    /**
     * Single geographic point represented by two double fields.
     *
     * @generated from field: cmp.types.v2.Coordinates source_location_coordinates = 8;
     */
    value: Coordinates;
    case: "sourceLocationCoordinates";
  } | {
    /**
     * Geo tree type, represented by Country, Region, and City_or_Resort.
     *
     * @generated from field: cmp.types.v2.GeoTree source_location_geo_tree = 9;
     */
    value: GeoTree;
    case: "sourceLocationGeoTree";
  } | {
    /**
     * Geo circle. Represented by a coordinate and a distance for radius
     *
     * @generated from field: cmp.types.v2.GeoCircle source_location_geo_circle = 10;
     */
    value: GeoCircle;
    case: "sourceLocationGeoCircle";
  } | {
    /**
     * Geo polygon. Represented by a list of coordinate points.
     *
     * @generated from field: cmp.types.v2.GeoPolygon source_location_geo_polygon = 11;
     */
    value: GeoPolygon;
    case: "sourceLocationGeoPolygon";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * For search, set only one of the field at once. Service location specifies the
   * areas involved in a ticket or excursion service. Service location indicates the
   * area of the requested services. Typical value would be the region or resort.
   * 
   * This one of field enforces only one of the fields below. They all share memory,
   * setting one will remove the others.
   *
   * @generated from oneof cmp.services.activity.v3.ActivitySearchRequest.service_location
   */
  serviceLocation: {
    /**
     * The code and code type of a stay location the distributor will be able to
     * process. Ex. Google Place ID, Foursquare fsq_id, OpenStreetMap Ref, Here ID or
     * any other agreed code type.
     *
     * @generated from field: cmp.types.v2.LocationCodes service_location_codes = 12;
     */
    value: LocationCodes;
    case: "serviceLocationCodes";
  } | {
    /**
     * Single geographic point represented by two double fields.
     *
     * @generated from field: cmp.types.v2.Coordinates service_location_coordinates = 13;
     */
    value: Coordinates;
    case: "serviceLocationCoordinates";
  } | {
    /**
     * Geo tree type, represented by Country, Region, and City_or_Resort.
     *
     * @generated from field: cmp.types.v2.GeoTree service_location_geo_tree = 14;
     */
    value: GeoTree;
    case: "serviceLocationGeoTree";
  } | {
    /**
     * Geo circle. Represented by a coordinate and a distance for radius
     *
     * @generated from field: cmp.types.v2.GeoCircle service_location_geo_circle = 15;
     */
    value: GeoCircle;
    case: "serviceLocationGeoCircle";
  } | {
    /**
     * Geo polygon. Represented by a list of coordinate points.
     *
     * @generated from field: cmp.types.v2.GeoPolygon service_location_geo_polygon = 16;
     */
    value: GeoPolygon;
    case: "serviceLocationGeoPolygon";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ActivitySearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v3.ActivitySearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "metadata", kind: "message", T: SearchRequestMetadata },
    { no: 3, name: "search_parameters_generic", kind: "message", T: SearchParameters },
    { no: 4, name: "search_parameters_activity", kind: "message", T: ActivitySearchParameters },
    { no: 5, name: "travel_period", kind: "message", T: TravelPeriod },
    { no: 6, name: "travellers", kind: "message", T: BasicTraveller, repeated: true },
    { no: 7, name: "source_location_codes", kind: "message", T: LocationCodes, oneof: "source_location" },
    { no: 8, name: "source_location_coordinates", kind: "message", T: Coordinates, oneof: "source_location" },
    { no: 9, name: "source_location_geo_tree", kind: "message", T: GeoTree, oneof: "source_location" },
    { no: 10, name: "source_location_geo_circle", kind: "message", T: GeoCircle, oneof: "source_location" },
    { no: 11, name: "source_location_geo_polygon", kind: "message", T: GeoPolygon, oneof: "source_location" },
    { no: 12, name: "service_location_codes", kind: "message", T: LocationCodes, oneof: "service_location" },
    { no: 13, name: "service_location_coordinates", kind: "message", T: Coordinates, oneof: "service_location" },
    { no: 14, name: "service_location_geo_tree", kind: "message", T: GeoTree, oneof: "service_location" },
    { no: 15, name: "service_location_geo_circle", kind: "message", T: GeoCircle, oneof: "service_location" },
    { no: 16, name: "service_location_geo_polygon", kind: "message", T: GeoPolygon, oneof: "service_location" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchRequest {
    return new ActivitySearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchRequest | PlainMessage<ActivitySearchRequest> | undefined, b: ActivitySearchRequest | PlainMessage<ActivitySearchRequest> | undefined): boolean {
    return proto3.util.equals(ActivitySearchRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.activity.v3.ActivitySearchResponse
 */
export class ActivitySearchResponse extends Message<ActivitySearchResponse> {
  /**
   * Message header. Contains API version, message info string and end user wallet
   * address.
   *
   * @generated from field: cmp.types.v1.ResponseHeader header = 1;
   */
  header?: ResponseHeader;

  /**
   * Search response metadata
   * 
   * The most important field is the search_id, which is a UUID that needs to be
   * carried through to the validate request.
   *
   * @generated from field: cmp.types.v3.SearchResponseMetadata metadata = 2;
   */
  metadata?: SearchResponseMetadata;

  /**
   * Unique combinations of bookable search results, each identified by a result_id
   * that needs to be carried through to the validate request.
   *
   * @generated from field: repeated cmp.services.activity.v3.ActivitySearchResult results = 3;
   */
  results: ActivitySearchResult[] = [];

  /**
   * The traveller_id is specified in each result and the ids are detailed with
   * basic traveller data only once in the top-level search response to avoid
   * repetition.
   *
   * @generated from field: repeated cmp.types.v3.BasicTraveller travellers = 4;
   */
  travellers: BasicTraveller[] = [];

  constructor(data?: PartialMessage<ActivitySearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.activity.v3.ActivitySearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResponseHeader },
    { no: 2, name: "metadata", kind: "message", T: SearchResponseMetadata },
    { no: 3, name: "results", kind: "message", T: ActivitySearchResult, repeated: true },
    { no: 4, name: "travellers", kind: "message", T: BasicTraveller, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivitySearchResponse {
    return new ActivitySearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActivitySearchResponse | PlainMessage<ActivitySearchResponse> | undefined, b: ActivitySearchResponse | PlainMessage<ActivitySearchResponse> | undefined): boolean {
    return proto3.util.equals(ActivitySearchResponse, a, b);
  }
}

