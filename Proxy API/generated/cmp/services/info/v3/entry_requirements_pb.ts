// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/info/v3/entry_requirements.proto (package cmp.services.info.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { ErrorResponseHeader, RequestHeader, SuccessResponseHeader } from "../../../types/v4/common_pb";
import { Country } from "../../../types/v2/country_pb";
import { TravelType } from "../../../types/v1/travel_type_pb";
import { DateTimeRange } from "../../../types/v4/datetime_range_pb";
import { Language } from "../../../types/v1/language_pb";
import { UUID } from "../../../types/v4/uuid_pb";
import { LocalizedString } from "../../../types/v4/localized_pb";

/**
 * Status identifies whether an item should be done/provided or rather not. In case
 * of an incident, there might be restrictions.
 * 
 * UNKNOWN is different from UNSPECIFIED. For UNKNOWN information about this topic
 * was sought, but it was not possible to find enough information to classify that
 * topic
 *
 * @generated from enum cmp.services.info.v3.ItemStatus
 */
export enum ItemStatus {
  /**
   * @generated from enum value: ITEM_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ITEM_STATUS_TRUE = 1;
   */
  TRUE = 1,

  /**
   * @generated from enum value: ITEM_STATUS_FALSE = 2;
   */
  FALSE = 2,

  /**
   * @generated from enum value: ITEM_STATUS_CRISIS = 3;
   */
  CRISIS = 3,

  /**
   * @generated from enum value: ITEM_STATUS_RESTRICTIONS = 4;
   */
  RESTRICTIONS = 4,

  /**
   * @generated from enum value: ITEM_STATUS_NO_RESTRICTIONS = 5;
   */
  NO_RESTRICTIONS = 5,

  /**
   * @generated from enum value: ITEM_STATUS_UNKNOWN = 6;
   */
  UNKNOWN = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ItemStatus)
proto3.util.setEnumType(ItemStatus, "cmp.services.info.v3.ItemStatus", [
  { no: 0, name: "ITEM_STATUS_UNSPECIFIED" },
  { no: 1, name: "ITEM_STATUS_TRUE" },
  { no: 2, name: "ITEM_STATUS_FALSE" },
  { no: 3, name: "ITEM_STATUS_CRISIS" },
  { no: 4, name: "ITEM_STATUS_RESTRICTIONS" },
  { no: 5, name: "ITEM_STATUS_NO_RESTRICTIONS" },
  { no: 6, name: "ITEM_STATUS_UNKNOWN" },
]);

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementsRequest
 */
export class CountryEntryRequirementsRequest extends Message<CountryEntryRequirementsRequest> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v4.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Departure country
   *
   * @generated from field: cmp.types.v2.Country departure = 2;
   */
  departure = Country.UNSPECIFIED;

  /**
   * Destination country
   *
   * @generated from field: cmp.types.v2.Country destination = 3;
   */
  destination = Country.UNSPECIFIED;

  /**
   * Citizenship
   *
   * @generated from field: cmp.types.v2.Country citizenship = 4;
   */
  citizenship = Country.UNSPECIFIED;

  /**
   * Residence
   *
   * @generated from field: cmp.types.v2.Country residence = 5;
   */
  residence = Country.UNSPECIFIED;

  /**
   * Transit country
   *
   * @generated from field: cmp.types.v2.Country transit = 6;
   */
  transit = Country.UNSPECIFIED;

  /**
   * Travel type, ex: business or tourism
   *
   * @generated from field: cmp.types.v1.TravelType travel_type = 7;
   */
  travelType = TravelType.UNSPECIFIED;

  /**
   * Date time range, start and end dates of visit, as timestamp.
   *
   * @generated from field: cmp.types.v4.DateTimeRange datetime_range = 8;
   */
  datetimeRange?: DateTimeRange;

  /**
   * Languages requested
   *
   * @generated from field: repeated cmp.types.v1.Language languages = 9;
   */
  languages: Language[] = [];

  /**
   * Flag to exclude categories (default: false)
   * This will prevent the list of `CountryEntryRequirementCategory`
   * from being included in the response.
   *
   * @generated from field: bool exclude_categories = 10;
   */
  excludeCategories = false;

  /**
   * Flag to include items (default: false)
   * This will include the list of `CountryEntryRequirementItem` in the response.
   *
   * @generated from field: bool include_items = 11;
   */
  includeItems = false;

  constructor(data?: PartialMessage<CountryEntryRequirementsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "departure", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 3, name: "destination", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 4, name: "citizenship", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 5, name: "residence", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 6, name: "transit", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 7, name: "travel_type", kind: "enum", T: proto3.getEnumType(TravelType) },
    { no: 8, name: "datetime_range", kind: "message", T: DateTimeRange },
    { no: 9, name: "languages", kind: "enum", T: proto3.getEnumType(Language), repeated: true },
    { no: 10, name: "exclude_categories", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "include_items", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsRequest | PlainMessage<CountryEntryRequirementsRequest> | undefined, b: CountryEntryRequirementsRequest | PlainMessage<CountryEntryRequirementsRequest> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementsSuccessResponse
 */
export class CountryEntryRequirementsSuccessResponse extends Message<CountryEntryRequirementsSuccessResponse> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v4.SuccessResponseHeader header = 1;
   */
  header?: SuccessResponseHeader;

  /**
   * This must be a UUID according to RFC 4122
   *
   * @generated from field: cmp.types.v4.UUID response_id = 2;
   */
  responseId?: UUID;

  /**
   * Categories
   *
   * @generated from field: repeated cmp.services.info.v3.CountryEntryRequirementCategory categories = 3;
   */
  categories: CountryEntryRequirementCategory[] = [];

  /**
   * Items
   *
   * @generated from field: repeated cmp.services.info.v3.CountryEntryRequirementItem items = 4;
   */
  items: CountryEntryRequirementItem[] = [];

  constructor(data?: PartialMessage<CountryEntryRequirementsSuccessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementsSuccessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: SuccessResponseHeader },
    { no: 2, name: "response_id", kind: "message", T: UUID },
    { no: 3, name: "categories", kind: "message", T: CountryEntryRequirementCategory, repeated: true },
    { no: 4, name: "items", kind: "message", T: CountryEntryRequirementItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsSuccessResponse {
    return new CountryEntryRequirementsSuccessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsSuccessResponse {
    return new CountryEntryRequirementsSuccessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsSuccessResponse {
    return new CountryEntryRequirementsSuccessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsSuccessResponse | PlainMessage<CountryEntryRequirementsSuccessResponse> | undefined, b: CountryEntryRequirementsSuccessResponse | PlainMessage<CountryEntryRequirementsSuccessResponse> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsSuccessResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementsErrorResponse
 */
export class CountryEntryRequirementsErrorResponse extends Message<CountryEntryRequirementsErrorResponse> {
  /**
   * Common error response header used in every error response.
   *
   * @generated from field: cmp.types.v4.ErrorResponseHeader header = 1;
   */
  header?: ErrorResponseHeader;

  constructor(data?: PartialMessage<CountryEntryRequirementsErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementsErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ErrorResponseHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsErrorResponse {
    return new CountryEntryRequirementsErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsErrorResponse {
    return new CountryEntryRequirementsErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsErrorResponse {
    return new CountryEntryRequirementsErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsErrorResponse | PlainMessage<CountryEntryRequirementsErrorResponse> | undefined, b: CountryEntryRequirementsErrorResponse | PlainMessage<CountryEntryRequirementsErrorResponse> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsErrorResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementsResponse
 */
export class CountryEntryRequirementsResponse extends Message<CountryEntryRequirementsResponse> {
  /**
   * @generated from oneof cmp.services.info.v3.CountryEntryRequirementsResponse.response
   */
  response: {
    /**
     * @generated from field: cmp.services.info.v3.CountryEntryRequirementsSuccessResponse success_response = 1;
     */
    value: CountryEntryRequirementsSuccessResponse;
    case: "successResponse";
  } | {
    /**
     * @generated from field: cmp.services.info.v3.CountryEntryRequirementsErrorResponse error_response = 2;
     */
    value: CountryEntryRequirementsErrorResponse;
    case: "errorResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CountryEntryRequirementsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_response", kind: "message", T: CountryEntryRequirementsSuccessResponse, oneof: "response" },
    { no: 2, name: "error_response", kind: "message", T: CountryEntryRequirementsErrorResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsResponse | PlainMessage<CountryEntryRequirementsResponse> | undefined, b: CountryEntryRequirementsResponse | PlainMessage<CountryEntryRequirementsResponse> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementCategory
 */
export class CountryEntryRequirementCategory extends Message<CountryEntryRequirementCategory> {
  /**
   * Category key.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * List of localized names
   *
   * @generated from field: repeated cmp.types.v4.LocalizedString names = 2;
   */
  names: LocalizedString[] = [];

  /**
   * Items
   *
   * @generated from field: repeated cmp.services.info.v3.CountryEntryRequirementItem items = 3;
   */
  items: CountryEntryRequirementItem[] = [];

  /**
   * Sub categories
   *
   * @generated from field: repeated cmp.services.info.v3.CountryEntryRequirementCategory sub_categories = 4;
   */
  subCategories: CountryEntryRequirementCategory[] = [];

  constructor(data?: PartialMessage<CountryEntryRequirementCategory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementCategory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "names", kind: "message", T: LocalizedString, repeated: true },
    { no: 3, name: "items", kind: "message", T: CountryEntryRequirementItem, repeated: true },
    { no: 4, name: "sub_categories", kind: "message", T: CountryEntryRequirementCategory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementCategory | PlainMessage<CountryEntryRequirementCategory> | undefined, b: CountryEntryRequirementCategory | PlainMessage<CountryEntryRequirementCategory> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementCategory, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.CountryEntryRequirementItem
 */
export class CountryEntryRequirementItem extends Message<CountryEntryRequirementItem> {
  /**
   * Item type key.  FIXME: Can this field be an enum?
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Language specific names and descriptions
   *
   * @generated from field: repeated cmp.services.info.v3.LocalizedItemInfo info = 2;
   */
  info: LocalizedItemInfo[] = [];

  /**
   * Status of the item. An item specifies an action or requirement which should be
   * done/provided or rather not. This is expressed with "true" and "false".
   * Examples:
   * Entry generally permitted, status=true
   * EU Digital COVID Certificate accepted, status=true
   * Visa required for stay, status=false
   * Entry forms required, status=false
   * Additional information, status=undefined
   *
   * @generated from field: cmp.services.info.v3.ItemStatus status = 3;
   */
  status = ItemStatus.UNSPECIFIED;

  /**
   * Significant update date
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp last_significant_update = 4;
   */
  lastSignificantUpdate?: Timestamp;

  constructor(data?: PartialMessage<CountryEntryRequirementItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.CountryEntryRequirementItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info", kind: "message", T: LocalizedItemInfo, repeated: true },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(ItemStatus) },
    { no: 4, name: "last_significant_update", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementItem | PlainMessage<CountryEntryRequirementItem> | undefined, b: CountryEntryRequirementItem | PlainMessage<CountryEntryRequirementItem> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementItem, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v3.LocalizedItemInfo
 */
export class LocalizedItemInfo extends Message<LocalizedItemInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: cmp.types.v1.Language language = 3;
   */
  language = Language.UNSPECIFIED;

  constructor(data?: PartialMessage<LocalizedItemInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v3.LocalizedItemInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "language", kind: "enum", T: proto3.getEnumType(Language) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedItemInfo | PlainMessage<LocalizedItemInfo> | undefined, b: LocalizedItemInfo | PlainMessage<LocalizedItemInfo> | undefined): boolean {
    return proto3.util.equals(LocalizedItemInfo, a, b);
  }
}

