// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/info/v1/entry_requirements.proto (package cmp.services.info.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { RequestHeader, ResponseHeader } from "../../../types/v1/common_pb";
import { Country } from "../../../types/v1/country_pb";
import { TravelType } from "../../../types/v1/travel_type_pb";
import { DateTimeRange } from "../../../types/v1/datetime_range_pb";
import { Language } from "../../../types/v1/language_pb";
import { Filter } from "../../../types/v1/filter_pb";
import { UUID } from "../../../types/v1/uuid_pb";
import { LocalizedString } from "../../../types/v1/localized_pb";

/**
 * Status identifies whether an item should be done/provided or rather not. In case
 * of an incident, there might be restrictions.
 * 
 * UNKNOWN is different from UNSPECIFIED. For UNKNOWN information about this topic
 * was sought, but it was not possible to find enough information to classify that
 * topic
 *
 * @generated from enum cmp.services.info.v1.ItemStatus
 */
export enum ItemStatus {
  /**
   * @generated from enum value: ITEM_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ITEM_STATUS_TRUE = 1;
   */
  TRUE = 1,

  /**
   * @generated from enum value: ITEM_STATUS_FALSE = 2;
   */
  FALSE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ItemStatus)
proto3.util.setEnumType(ItemStatus, "cmp.services.info.v1.ItemStatus", [
  { no: 0, name: "ITEM_STATUS_UNSPECIFIED" },
  { no: 1, name: "ITEM_STATUS_TRUE" },
  { no: 2, name: "ITEM_STATUS_FALSE" },
]);

/**
 * @generated from message cmp.services.info.v1.CountryEntryRequirementsRequest
 */
export class CountryEntryRequirementsRequest extends Message<CountryEntryRequirementsRequest> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v1.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Departure country
   *
   * @generated from field: cmp.types.v1.Country departure = 2;
   */
  departure = Country.UNSPECIFIED;

  /**
   * Destination country
   *
   * @generated from field: cmp.types.v1.Country destination = 3;
   */
  destination = Country.UNSPECIFIED;

  /**
   * Citizenship
   *
   * @generated from field: cmp.types.v1.Country citizenship = 4;
   */
  citizenship = Country.UNSPECIFIED;

  /**
   * Residence
   *
   * @generated from field: cmp.types.v1.Country residence = 5;
   */
  residence = Country.UNSPECIFIED;

  /**
   * Transit country
   *
   * @generated from field: cmp.types.v1.Country transit = 6;
   */
  transit = Country.UNSPECIFIED;

  /**
   * Travel type, ex: business or tourism
   *
   * @generated from field: cmp.types.v1.TravelType travel_type = 7;
   */
  travelType = TravelType.UNSPECIFIED;

  /**
   * Date time range, start and end dates of visit, as timestamp.
   *
   * @generated from field: cmp.types.v1.DateTimeRange datetime_range = 8;
   */
  datetimeRange?: DateTimeRange;

  /**
   * Languages requested
   *
   * @generated from field: repeated cmp.types.v1.Language languages = 9;
   */
  languages: Language[] = [];

  /**
   * @generated from field: bool exclude_categories = 10;
   */
  excludeCategories = false;

  /**
   * @generated from field: bool include_items = 11;
   */
  includeItems = false;

  /**
   * There is not yet any categorization standard and conclusively filters are
   * supplier specific and the filter type should be "FILTER_TYPE_PROVIDER_CODE"
   * Examples:
   *
   * @generated from field: repeated cmp.types.v1.Filter filters = 12;
   */
  filters: Filter[] = [];

  constructor(data?: PartialMessage<CountryEntryRequirementsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v1.CountryEntryRequirementsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "departure", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 3, name: "destination", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 4, name: "citizenship", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 5, name: "residence", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 6, name: "transit", kind: "enum", T: proto3.getEnumType(Country) },
    { no: 7, name: "travel_type", kind: "enum", T: proto3.getEnumType(TravelType) },
    { no: 8, name: "datetime_range", kind: "message", T: DateTimeRange },
    { no: 9, name: "languages", kind: "enum", T: proto3.getEnumType(Language), repeated: true },
    { no: 10, name: "exclude_categories", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "include_items", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "filters", kind: "message", T: Filter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsRequest {
    return new CountryEntryRequirementsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsRequest | PlainMessage<CountryEntryRequirementsRequest> | undefined, b: CountryEntryRequirementsRequest | PlainMessage<CountryEntryRequirementsRequest> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v1.CountryEntryRequirementsResponse
 */
export class CountryEntryRequirementsResponse extends Message<CountryEntryRequirementsResponse> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v1.ResponseHeader header = 1;
   */
  header?: ResponseHeader;

  /**
   * This must be a UUID according to RFC 4122
   *
   * @generated from field: cmp.types.v1.UUID response_id = 2;
   */
  responseId?: UUID;

  /**
   * Categories
   *
   * @generated from field: repeated cmp.services.info.v1.CountryEntryRequirementCategory categories = 3;
   */
  categories: CountryEntryRequirementCategory[] = [];

  /**
   * Items
   *
   * @generated from field: repeated cmp.services.info.v1.CountryEntryRequirementItem items = 4;
   */
  items: CountryEntryRequirementItem[] = [];

  constructor(data?: PartialMessage<CountryEntryRequirementsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v1.CountryEntryRequirementsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResponseHeader },
    { no: 2, name: "response_id", kind: "message", T: UUID },
    { no: 3, name: "categories", kind: "message", T: CountryEntryRequirementCategory, repeated: true },
    { no: 4, name: "items", kind: "message", T: CountryEntryRequirementItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementsResponse {
    return new CountryEntryRequirementsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementsResponse | PlainMessage<CountryEntryRequirementsResponse> | undefined, b: CountryEntryRequirementsResponse | PlainMessage<CountryEntryRequirementsResponse> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementsResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v1.CountryEntryRequirementCategory
 */
export class CountryEntryRequirementCategory extends Message<CountryEntryRequirementCategory> {
  /**
   * Category key.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * List of localized names
   *
   * @generated from field: repeated cmp.types.v1.LocalizedString names = 2;
   */
  names: LocalizedString[] = [];

  /**
   * Items
   *
   * @generated from field: repeated cmp.services.info.v1.CountryEntryRequirementItem items = 3;
   */
  items: CountryEntryRequirementItem[] = [];

  /**
   * Sub categories
   *
   * @generated from field: repeated cmp.services.info.v1.CountryEntryRequirementCategory sub_categories = 4;
   */
  subCategories: CountryEntryRequirementCategory[] = [];

  constructor(data?: PartialMessage<CountryEntryRequirementCategory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v1.CountryEntryRequirementCategory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "names", kind: "message", T: LocalizedString, repeated: true },
    { no: 3, name: "items", kind: "message", T: CountryEntryRequirementItem, repeated: true },
    { no: 4, name: "sub_categories", kind: "message", T: CountryEntryRequirementCategory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementCategory {
    return new CountryEntryRequirementCategory().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementCategory | PlainMessage<CountryEntryRequirementCategory> | undefined, b: CountryEntryRequirementCategory | PlainMessage<CountryEntryRequirementCategory> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementCategory, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v1.CountryEntryRequirementItem
 */
export class CountryEntryRequirementItem extends Message<CountryEntryRequirementItem> {
  /**
   * Item type key.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Language specific names and descriptions
   *
   * @generated from field: repeated cmp.services.info.v1.LocalizedItemInfo info = 2;
   */
  info: LocalizedItemInfo[] = [];

  /**
   * Status of the item. An item specifies an action or requirement which should be
   * done/provided or rather not. This is expressed with "true" and "false".
   * Examples:
   * Entry generally permitted, status=true
   * EU Digital COVID Certificate accepted, status=true
   * Visa required for stay, status=false
   * Entry forms required, status=false
   * Additional information, status=undefined
   *
   * @generated from field: cmp.services.info.v1.ItemStatus status = 3;
   */
  status = ItemStatus.UNSPECIFIED;

  /**
   * Significant update date
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp last_significant_update = 4;
   */
  lastSignificantUpdate?: Timestamp;

  constructor(data?: PartialMessage<CountryEntryRequirementItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v1.CountryEntryRequirementItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info", kind: "message", T: LocalizedItemInfo, repeated: true },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(ItemStatus) },
    { no: 4, name: "last_significant_update", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountryEntryRequirementItem {
    return new CountryEntryRequirementItem().fromJsonString(jsonString, options);
  }

  static equals(a: CountryEntryRequirementItem | PlainMessage<CountryEntryRequirementItem> | undefined, b: CountryEntryRequirementItem | PlainMessage<CountryEntryRequirementItem> | undefined): boolean {
    return proto3.util.equals(CountryEntryRequirementItem, a, b);
  }
}

/**
 * @generated from message cmp.services.info.v1.LocalizedItemInfo
 */
export class LocalizedItemInfo extends Message<LocalizedItemInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: cmp.types.v1.Language language = 3;
   */
  language = Language.UNSPECIFIED;

  constructor(data?: PartialMessage<LocalizedItemInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.info.v1.LocalizedItemInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "language", kind: "enum", T: proto3.getEnumType(Language) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalizedItemInfo {
    return new LocalizedItemInfo().fromJsonString(jsonString, options);
  }

  static equals(a: LocalizedItemInfo | PlainMessage<LocalizedItemInfo> | undefined, b: LocalizedItemInfo | PlainMessage<LocalizedItemInfo> | undefined): boolean {
    return proto3.util.equals(LocalizedItemInfo, a, b);
  }
}

