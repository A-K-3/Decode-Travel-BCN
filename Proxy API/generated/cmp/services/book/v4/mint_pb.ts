// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/book/v4/mint.proto (package cmp.services.book.v4, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ErrorResponseHeader, RequestHeader, SuccessResponseHeader } from "../../../types/v4/common_pb";
import { UUID } from "../../../types/v4/uuid_pb";
import { ExtensiveTraveller } from "../../../types/v4/traveller_pb";
import { PublicKey } from "../../../types/v4/pubkey_pb";
import { EVMAddress } from "../../../types/v4/evm_address_pb";
import { AdditionalPaymentInfo } from "../../../types/v4/payment_pb";
import { Price } from "../../../types/v4/price_pb";
import { EVMTransactionID } from "../../../types/v4/evm_transaction_pb";

/**
 * @generated from message cmp.services.book.v4.MintRequest
 */
export class MintRequest extends Message<MintRequest> {
  /**
   * Common header which is used in every request.
   *
   * @generated from field: cmp.types.v4.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * The validation ID obtained from the ValidationResponse.
   *
   * @generated from field: cmp.types.v4.UUID validation_id = 2;
   */
  validationId?: UUID;

  /**
   * Optional booking reference provided by the buyer system to identify
   * the booking.
   *
   * @generated from field: string booking_reference = 3;
   */
  bookingReference = "";

  /**
   * Up until this point no identifying traveller information has been
   * provided. This must be provided here to allow for minting the booking
   * token with the traveller details.
   *
   * @generated from field: repeated cmp.types.v4.ExtensiveTraveller travellers = 4;
   */
  travellers: ExtensiveTraveller[] = [];

  /**
   * The comments field is meant to pass noncommittal remarks entered by the
   * end-consumer about the service reservation,  like "non-smoking room please",
   * "top floor room please".
   *
   * @generated from field: string comment = 5;
   */
  comment = "";

  /**
   * Public keys that will be used to encrypt the private booking data
   *
   * @generated from field: repeated cmp.types.v4.PublicKey public_keys = 6;
   */
  publicKeys: PublicKey[] = [];

  /**
   * Buyer's address. Only this address should be allowed to buy the `BookingToken`
   * on chain.
   *
   * @generated from field: cmp.types.v4.EVMAddress buyer_address = 7;
   */
  buyerAddress?: EVMAddress;

  /**
   * This field is only relevant for off chain virtual credit card payments.
   *
   * @generated from field: cmp.types.v4.AdditionalPaymentInfo additional_payment_info = 8;
   */
  additionalPaymentInfo?: AdditionalPaymentInfo;

  /**
   * Expected BookingToken price. This price should be used by the bot to verify
   * that the CMAccount of the distributor has enough funds to buy the minted
   * BookingToken.
   *
   * @generated from field: cmp.types.v4.Price expected_price = 9;
   */
  expectedPrice?: Price;

  constructor(data?: PartialMessage<MintRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v4.MintRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "validation_id", kind: "message", T: UUID },
    { no: 3, name: "booking_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "travellers", kind: "message", T: ExtensiveTraveller, repeated: true },
    { no: 5, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "public_keys", kind: "message", T: PublicKey, repeated: true },
    { no: 7, name: "buyer_address", kind: "message", T: EVMAddress },
    { no: 8, name: "additional_payment_info", kind: "message", T: AdditionalPaymentInfo },
    { no: 9, name: "expected_price", kind: "message", T: Price },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintRequest {
    return new MintRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintRequest {
    return new MintRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintRequest {
    return new MintRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MintRequest | PlainMessage<MintRequest> | undefined, b: MintRequest | PlainMessage<MintRequest> | undefined): boolean {
    return proto3.util.equals(MintRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.book.v4.MintSuccessResponse
 */
export class MintSuccessResponse extends Message<MintSuccessResponse> {
  /**
   * Common header which is used in every response.
   *
   * @generated from field: cmp.types.v4.SuccessResponseHeader header = 1;
   */
  header?: SuccessResponseHeader;

  /**
   * Unique mint ID for the minting operation.
   *
   * @generated from field: cmp.types.v4.UUID mint_id = 2;
   */
  mintId?: UUID;

  /**
   * The validation ID obtained from the ValidationResponse.
   *
   * @generated from field: cmp.types.v4.UUID validation_id = 3;
   */
  validationId?: UUID;

  /**
   * Supplier specific booking reference from the supplier's inventory system.
   *
   * @generated from field: string supplier_booking_reference = 4;
   */
  supplierBookingReference = "";

  /**
   * Timestamp of the booking in the inventory system of the supplier.
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp supplier_booking_timestamp = 5;
   */
  supplierBookingTimestamp?: Timestamp;

  /**
   * Price of the `BookingToken`. This field is meant to be populated by the
   * supplier plugin and used by the supplier bot while minting the `BookingToken`.
   *
   * @generated from field: cmp.types.v4.Price price = 6;
   */
  price?: Price;

  /**
   * ID of the token that represents the booking of the service. This will be
   * populated by the supplier bot after the `BookingToken` is minted on chain.
   *
   * @generated from field: uint64 booking_token_id = 7;
   */
  bookingTokenId = protoInt64.zero;

  /**
   * URI of the token that represents the booking of the service. This should be
   * populated by the Supplier partner plugin. It is up to the supplier to decide
   * what kind of storage (IPFS, HTTP, ...) to use here.
   *
   * @generated from field: string booking_token_uri = 8;
   */
  bookingTokenUri = "";

  /**
   * Mint transaction ID that will be populated by the supplier bot after the
   * `BookingToken` is minted on chain.
   *
   * @generated from field: cmp.types.v4.EVMTransactionID mint_transaction_id = 9;
   */
  mintTransactionId?: EVMTransactionID;

  /**
   * On chain booking token should be only buyable until this timestamp and should
   * expire after that.
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp buyable_until = 10;
   */
  buyableUntil?: Timestamp;

  /**
   * Transaction ID of the buy operation. This field is populated by the distributor
   * (buyer) bot after the buy operation and passed to the distributor middleware
   * (partner plugin) in the mint response.
   * 
   * This field is not meant for the supplier.
   *
   * @generated from field: cmp.types.v4.EVMTransactionID buy_transaction_id = 11;
   */
  buyTransactionId?: EVMTransactionID;

  /**
   * This field indicates whether the booking can be cancelled. If this field is not
   * used, the default value is false, which means the booking cannot be cancelled.
   * If cancellation is at all possible, the field must be set to true AND cancellation
   * via the messenger MUST be implemented. If cancellation of an on-chain minted
   * booking would be possible via extranet, email or phone, the status of a booking
   * on the Camino Network would become inconsistent and the ledger functionality
   * of the blockchain would be undermined. Disputes will reoccur. This kind of flows
   * are strongly discouraged.
   *
   * @generated from field: bool cancellable = 12;
   */
  cancellable = false;

  constructor(data?: PartialMessage<MintSuccessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v4.MintSuccessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: SuccessResponseHeader },
    { no: 2, name: "mint_id", kind: "message", T: UUID },
    { no: 3, name: "validation_id", kind: "message", T: UUID },
    { no: 4, name: "supplier_booking_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "supplier_booking_timestamp", kind: "message", T: Timestamp },
    { no: 6, name: "price", kind: "message", T: Price },
    { no: 7, name: "booking_token_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "booking_token_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "mint_transaction_id", kind: "message", T: EVMTransactionID },
    { no: 10, name: "buyable_until", kind: "message", T: Timestamp },
    { no: 11, name: "buy_transaction_id", kind: "message", T: EVMTransactionID },
    { no: 12, name: "cancellable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintSuccessResponse {
    return new MintSuccessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintSuccessResponse {
    return new MintSuccessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintSuccessResponse {
    return new MintSuccessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MintSuccessResponse | PlainMessage<MintSuccessResponse> | undefined, b: MintSuccessResponse | PlainMessage<MintSuccessResponse> | undefined): boolean {
    return proto3.util.equals(MintSuccessResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.book.v4.MintErrorResponse
 */
export class MintErrorResponse extends Message<MintErrorResponse> {
  /**
   * Common error response header used in every error response.
   *
   * @generated from field: cmp.types.v4.ErrorResponseHeader header = 1;
   */
  header?: ErrorResponseHeader;

  constructor(data?: PartialMessage<MintErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v4.MintErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ErrorResponseHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintErrorResponse {
    return new MintErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintErrorResponse {
    return new MintErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintErrorResponse {
    return new MintErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MintErrorResponse | PlainMessage<MintErrorResponse> | undefined, b: MintErrorResponse | PlainMessage<MintErrorResponse> | undefined): boolean {
    return proto3.util.equals(MintErrorResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.book.v4.MintResponse
 */
export class MintResponse extends Message<MintResponse> {
  /**
   * @generated from oneof cmp.services.book.v4.MintResponse.response
   */
  response: {
    /**
     * @generated from field: cmp.services.book.v4.MintSuccessResponse success_response = 1;
     */
    value: MintSuccessResponse;
    case: "successResponse";
  } | {
    /**
     * @generated from field: cmp.services.book.v4.MintErrorResponse error_response = 2;
     */
    value: MintErrorResponse;
    case: "errorResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MintResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v4.MintResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_response", kind: "message", T: MintSuccessResponse, oneof: "response" },
    { no: 2, name: "error_response", kind: "message", T: MintErrorResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintResponse {
    return new MintResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintResponse {
    return new MintResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintResponse {
    return new MintResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MintResponse | PlainMessage<MintResponse> | undefined, b: MintResponse | PlainMessage<MintResponse> | undefined): boolean {
    return proto3.util.equals(MintResponse, a, b);
  }
}

