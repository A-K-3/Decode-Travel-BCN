// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/book/v3/mint.proto (package cmp.services.book.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { RequestHeader, ResponseHeader } from "../../../types/v1/common_pb";
import { UUID } from "../../../types/v1/uuid_pb";
import { Language } from "../../../types/v1/language_pb";
import { ExtensiveTraveller } from "../../../types/v3/traveller_pb";
import { PublicKey } from "../../../types/v1/pubkey_pb";
import { EVMAddress } from "../../../types/v3/evm_address_pb";
import { AdditionalPaymentInfo } from "../../../types/v3/payment_pb";
import { Price } from "../../../types/v3/price_pb";
import { EVMTransactionID } from "../../../types/v3/evm_transaction_pb";

/**
 * @generated from message cmp.services.book.v3.MintRequest
 */
export class MintRequest extends Message<MintRequest> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v1.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * This must be a UUID according to RFC 4122
   *
   * @generated from field: cmp.types.v1.UUID validation_id = 2;
   */
  validationId?: UUID;

  /**
   * @generated from field: string external_session_id = 3;
   */
  externalSessionId = "";

  /**
   * @generated from field: cmp.types.v1.Language language = 4;
   */
  language = Language.UNSPECIFIED;

  /**
   * @generated from field: string market = 5;
   */
  market = "";

  /**
   * @generated from field: string booking_reference = 6;
   */
  bookingReference = "";

  /**
   * @generated from field: repeated cmp.types.v3.ExtensiveTraveller travellers = 7;
   */
  travellers: ExtensiveTraveller[] = [];

  /**
   * The comments field is meant to pass noncommittal remarks entered by the
   * end-consumer about the service reservation,  like "non-smoking room please",
   * "top floor room please".
   *
   * @generated from field: string comment = 8;
   */
  comment = "";

  /**
   * Public keys that will be used to encrypt the private booking data
   *
   * @generated from field: repeated cmp.types.v1.PublicKey public_keys = 9;
   */
  publicKeys: PublicKey[] = [];

  /**
   * Buyer's address. Only this address should be allowed to buy the `BookingToken`
   * on chain.
   *
   * @generated from field: cmp.types.v3.EVMAddress buyer_address = 10;
   */
  buyerAddress?: EVMAddress;

  /**
   * This field is only relevant for off chain virtual credit card payments.
   *
   * @generated from field: cmp.types.v3.AdditionalPaymentInfo additional_payment_info = 11;
   */
  additionalPaymentInfo?: AdditionalPaymentInfo;

  constructor(data?: PartialMessage<MintRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v3.MintRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "validation_id", kind: "message", T: UUID },
    { no: 3, name: "external_session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "language", kind: "enum", T: proto3.getEnumType(Language) },
    { no: 5, name: "market", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "booking_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "travellers", kind: "message", T: ExtensiveTraveller, repeated: true },
    { no: 8, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "public_keys", kind: "message", T: PublicKey, repeated: true },
    { no: 10, name: "buyer_address", kind: "message", T: EVMAddress },
    { no: 11, name: "additional_payment_info", kind: "message", T: AdditionalPaymentInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintRequest {
    return new MintRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintRequest {
    return new MintRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintRequest {
    return new MintRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MintRequest | PlainMessage<MintRequest> | undefined, b: MintRequest | PlainMessage<MintRequest> | undefined): boolean {
    return proto3.util.equals(MintRequest, a, b);
  }
}

/**
 * @generated from message cmp.services.book.v3.MintResponse
 */
export class MintResponse extends Message<MintResponse> {
  /**
   * Message header
   *
   * @generated from field: cmp.types.v1.ResponseHeader header = 1;
   */
  header?: ResponseHeader;

  /**
   * This must be a UUID according to RFC 4122
   *
   * @generated from field: cmp.types.v1.UUID mint_id = 2;
   */
  mintId?: UUID;

  /**
   * This must be a UUID according to RFC 4122
   *
   * @generated from field: cmp.types.v1.UUID validation_id = 3;
   */
  validationId?: UUID;

  /**
   * @generated from field: string provider_booking_reference = 4;
   */
  providerBookingReference = "";

  /**
   * Timestamp of the booking in the inventory system of the supplier.
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp provider_booking_timestamp = 5;
   */
  providerBookingTimestamp?: Timestamp;

  /**
   * Price of the `BookingToken`. This field is meant to be populated by the
   * supplier plugin and used by the supplier bot while minting the `BookingToken`.
   *
   * @generated from field: cmp.types.v3.Price price = 6;
   */
  price?: Price;

  /**
   * ID of the token that represents the booking of the service. This will be
   * populated by the supplier bot after the `BookingToken` is minted on chain.
   *
   * @generated from field: uint64 booking_token_id = 7;
   */
  bookingTokenId = protoInt64.zero;

  /**
   * URI of the token that represents the booking of the service. This should be
   * populated by the Supplier partner plugin. It is up to the supplier to decide
   * what kind of storage (IPFS, HTTP, ...) to use here.
   *
   * @generated from field: string booking_token_uri = 8;
   */
  bookingTokenUri = "";

  /**
   * Mint transaction ID that will be populated by the supplier bot after the
   * `BookingToken` is minted on chain.
   *
   * @generated from field: cmp.types.v3.EVMTransactionID mint_transaction_id = 9;
   */
  mintTransactionId?: EVMTransactionID;

  /**
   * On chain booking token should be only buyable until this timestamp and should
   * expire after that.
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp buyable_until = 10;
   */
  buyableUntil?: Timestamp;

  /**
   * Transaction ID of the buy operation. This field is populated by the distributor
   * (buyer) bot after the buy operation and passed to the distributor middleware
   * (partner plugin) in the mint response.
   * 
   * This field is not meant for the supplier.
   *
   * @generated from field: cmp.types.v3.EVMTransactionID buy_transaction_id = 11;
   */
  buyTransactionId?: EVMTransactionID;

  /**
   * This field indicates whether the booking can be cancelled. If this field is not
   * used, the default value is false, which means the booking cannot be cancelled.
   * If cancellation is at all possible, the field must be set to true AND cancellation
   * via the messenger MUST be implemented. If cancellation of an on-chain minted
   * booking would be possible via extranet, email or phone, the status of a booking
   * on the Camino Network would become inconsistent and the ledger functionality
   * of the blockchain would be undermined. Disputes will reoccur. This kind of flows
   * are strongly discouraged.
   *
   * @generated from field: bool cancellable = 12;
   */
  cancellable = false;

  constructor(data?: PartialMessage<MintResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.book.v3.MintResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResponseHeader },
    { no: 2, name: "mint_id", kind: "message", T: UUID },
    { no: 3, name: "validation_id", kind: "message", T: UUID },
    { no: 4, name: "provider_booking_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "provider_booking_timestamp", kind: "message", T: Timestamp },
    { no: 6, name: "price", kind: "message", T: Price },
    { no: 7, name: "booking_token_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "booking_token_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "mint_transaction_id", kind: "message", T: EVMTransactionID },
    { no: 10, name: "buyable_until", kind: "message", T: Timestamp },
    { no: 11, name: "buy_transaction_id", kind: "message", T: EVMTransactionID },
    { no: 12, name: "cancellable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MintResponse {
    return new MintResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MintResponse {
    return new MintResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MintResponse {
    return new MintResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MintResponse | PlainMessage<MintResponse> | undefined, b: MintResponse | PlainMessage<MintResponse> | undefined): boolean {
    return proto3.util.equals(MintResponse, a, b);
  }
}

