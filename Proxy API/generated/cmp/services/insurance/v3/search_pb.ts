// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/insurance/v3/search.proto (package cmp.services.insurance.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// ## InsuranceServices
//
// Insurance Services has two main processes:
//
// - selling insurances: this process follows the same flow as selling any travel
// product on the Camino Network: Static data download using the InsuranceProductList
// message to obtain the (changed) portfolio of product a supplier offers, followed by
// the InsuranceProductInfo message to get the exact detail of each product. The real-time data
// does not contain any static information and consists of the InsuranceSearch message, followed
// by the generic Validate and Mint messages.
//
// - making an insurance claim: this is a special workflow and further explained in the claim service
//
// further below you'll find the technical details of the insurance selling service.

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ErrorResponseHeader, RequestHeader, SuccessResponseHeader } from "../../../types/v4/common_pb";
import { SearchParameters } from "../../../types/v4/search_pb";
import { InsuranceSearchQuery } from "./search_query_types_pb";
import { UUID } from "../../../types/v4/uuid_pb";
import { InsuranceSearchResult } from "./search_result_types_pb";
import { BasicTraveller } from "../../../types/v4/traveller_pb";

/**
 * InsuranceSearchRequest
 * 
 * The Insurance Search Request message type facilitates the request for insurances
 * like health or cancellation insurances within the platform. In the request the market,
 * language and currency are specified at the top-level.
 * 
 * In "queries" we specify the details of the insurances we would like to be offered.
 * In the Response, each InsuranceSearchResult is one bookable option as a "result_id".
 * Each consists of a "product" which indicates a type of insurance and if more options of
 * one type are available, then different units are offered. In case of an additional service,
 * like a sports package in combination with a health insurance, you would find one search result
 * with just the health insurance and another search result with both the health insurance and
 * the sports package.
 *
 * @generated from message cmp.services.insurance.v3.InsuranceSearchRequest
 */
export class InsuranceSearchRequest extends Message<InsuranceSearchRequest> {
  /**
   * Message header. Contains API version, message info string and end-user wallet
   * address
   *
   * @generated from field: cmp.types.v4.RequestHeader header = 1;
   */
  header?: RequestHeader;

  /**
   * Generic search parameters Ex: Inclusion of OnRequest options and inclusion of
   * only the cheapest or all options.
   * In the search parameters multiple filters can be applied for upfront filtering
   * of the search results to for example to only include hotels that are less than
   * one kilometer from the beach, have a kids club and offer an a la carte restaurant
   *
   * @generated from field: cmp.types.v4.SearchParameters search_parameters = 2;
   */
  searchParameters?: SearchParameters;

  /**
   * This field represents a list of search queries that can be used to create
   * a request that covers multiple bookings, travellers that have a different
   * nationality or residence. Or for sequential travel periods.
   * what is important to realize is that each query, when booked will result
   * to one policy that can be claimed. It is never possible to only claim
   * part of a policy.
   * As insurances of different product families will be covered with different
   * carriers, never combine different product families in one request. These
   * are specified in the "insured_product_type" in the search parameters.
   * Instead of adding multiple product families into multiple queries, it is
   * recommended to split them into multiple requests so that they can be
   * processed in parallel.
   *
   * @generated from field: repeated cmp.services.insurance.v3.InsuranceSearchQuery queries = 3;
   */
  queries: InsuranceSearchQuery[] = [];

  constructor(data?: PartialMessage<InsuranceSearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.insurance.v3.InsuranceSearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: RequestHeader },
    { no: 2, name: "search_parameters", kind: "message", T: SearchParameters },
    { no: 3, name: "queries", kind: "message", T: InsuranceSearchQuery, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InsuranceSearchRequest {
    return new InsuranceSearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InsuranceSearchRequest {
    return new InsuranceSearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InsuranceSearchRequest {
    return new InsuranceSearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InsuranceSearchRequest | PlainMessage<InsuranceSearchRequest> | undefined, b: InsuranceSearchRequest | PlainMessage<InsuranceSearchRequest> | undefined): boolean {
    return proto3.util.equals(InsuranceSearchRequest, a, b);
  }
}

/**
 * The `Insurance Search Response` message type facilitates the response for
 * insurances like hotel and holiday home searches within the platform.
 * 
 * In the response a search_id must be included and a search_option_id for every
 * bookable option responded. Included, compulsory and optional services can be
 * included. A simple "free cancellation upto" can be set or full cancellation
 * policies can be included.
 *
 * @generated from message cmp.services.insurance.v3.InsuranceSearchSuccessResponse
 */
export class InsuranceSearchSuccessResponse extends Message<InsuranceSearchSuccessResponse> {
  /**
   * Message header. Contains API version, message info string and end user wallet
   * address.
   *
   * @generated from field: cmp.types.v4.SuccessResponseHeader header = 1;
   */
  header?: SuccessResponseHeader;

  /**
   * Search_id to be used in subsequent requests like the "Validation Request".
   *
   * @generated from field: cmp.types.v4.UUID search_id = 2;
   */
  searchId?: UUID;

  /**
   * Unique combinations of bookable search results, like property,
   *
   * @generated from field: repeated cmp.services.insurance.v3.InsuranceSearchResult results = 3;
   */
  results: InsuranceSearchResult[] = [];

  /**
   * Global definition of the travellers for all results to be used via the traveller_id each unit.
   *
   * @generated from field: repeated cmp.types.v4.BasicTraveller travellers = 4;
   */
  travellers: BasicTraveller[] = [];

  constructor(data?: PartialMessage<InsuranceSearchSuccessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.insurance.v3.InsuranceSearchSuccessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: SuccessResponseHeader },
    { no: 2, name: "search_id", kind: "message", T: UUID },
    { no: 3, name: "results", kind: "message", T: InsuranceSearchResult, repeated: true },
    { no: 4, name: "travellers", kind: "message", T: BasicTraveller, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InsuranceSearchSuccessResponse {
    return new InsuranceSearchSuccessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InsuranceSearchSuccessResponse {
    return new InsuranceSearchSuccessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InsuranceSearchSuccessResponse {
    return new InsuranceSearchSuccessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InsuranceSearchSuccessResponse | PlainMessage<InsuranceSearchSuccessResponse> | undefined, b: InsuranceSearchSuccessResponse | PlainMessage<InsuranceSearchSuccessResponse> | undefined): boolean {
    return proto3.util.equals(InsuranceSearchSuccessResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.insurance.v3.InsuranceSearchErrorResponse
 */
export class InsuranceSearchErrorResponse extends Message<InsuranceSearchErrorResponse> {
  /**
   * Common error response header used in every error response.
   *
   * @generated from field: cmp.types.v4.ErrorResponseHeader header = 1;
   */
  header?: ErrorResponseHeader;

  constructor(data?: PartialMessage<InsuranceSearchErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.insurance.v3.InsuranceSearchErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ErrorResponseHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InsuranceSearchErrorResponse {
    return new InsuranceSearchErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InsuranceSearchErrorResponse {
    return new InsuranceSearchErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InsuranceSearchErrorResponse {
    return new InsuranceSearchErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InsuranceSearchErrorResponse | PlainMessage<InsuranceSearchErrorResponse> | undefined, b: InsuranceSearchErrorResponse | PlainMessage<InsuranceSearchErrorResponse> | undefined): boolean {
    return proto3.util.equals(InsuranceSearchErrorResponse, a, b);
  }
}

/**
 * @generated from message cmp.services.insurance.v3.InsuranceSearchResponse
 */
export class InsuranceSearchResponse extends Message<InsuranceSearchResponse> {
  /**
   * @generated from oneof cmp.services.insurance.v3.InsuranceSearchResponse.response
   */
  response: {
    /**
     * @generated from field: cmp.services.insurance.v3.InsuranceSearchSuccessResponse success_response = 1;
     */
    value: InsuranceSearchSuccessResponse;
    case: "successResponse";
  } | {
    /**
     * @generated from field: cmp.services.insurance.v3.InsuranceSearchErrorResponse error_response = 2;
     */
    value: InsuranceSearchErrorResponse;
    case: "errorResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<InsuranceSearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.insurance.v3.InsuranceSearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success_response", kind: "message", T: InsuranceSearchSuccessResponse, oneof: "response" },
    { no: 2, name: "error_response", kind: "message", T: InsuranceSearchErrorResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InsuranceSearchResponse {
    return new InsuranceSearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InsuranceSearchResponse {
    return new InsuranceSearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InsuranceSearchResponse {
    return new InsuranceSearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InsuranceSearchResponse | PlainMessage<InsuranceSearchResponse> | undefined, b: InsuranceSearchResponse | PlainMessage<InsuranceSearchResponse> | undefined): boolean {
    return proto3.util.equals(InsuranceSearchResponse, a, b);
  }
}

