// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file cmp/services/transport/v3/trip_types.proto (package cmp.services.transport.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { ProductCode, SupplierProductCode } from "../../../types/v2/product_code_pb";
import { Baggage } from "../../../types/v1/baggage_pb";
import { Price } from "../../../types/v3/price_pb";
import { ServiceFact } from "../../../types/v3/service_fact_pb";
import { Duration } from "../../../types/v1/duration_pb";
import { Length } from "../../../types/v1/measurement_pb";
import { Coordinates, LocationCode } from "../../../types/v2/location_pb";

/**
 * This message type represents a one way trip, either travelling or returning.
 * 
 * ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/services/transport/v3/trip_types.proto.dot.xs.svg)
 * 
 * [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/services/transport/v3/trip_types.proto.dot.svg)
 *
 * @generated from message cmp.services.transport.v3.TripExtended
 */
export class TripExtended extends Message<TripExtended> {
  /**
   * Trip supplier code
   *
   * @generated from field: cmp.types.v2.SupplierProductCode supplier_code = 1;
   */
  supplierCode?: SupplierProductCode;

  /**
   * Luggage
   * 
   * Ex: `3`
   *
   * @generated from field: cmp.types.v1.Baggage baggage = 2;
   */
  baggage?: Baggage;

  /**
   * Price
   * 
   * Ex: `Price(net=240, currency=Currency.CURRENCY_EUR)
   *
   * @generated from field: cmp.types.v3.Price price = 3;
   */
  price?: Price;

  /**
   * Trip segments are the legs offered. Here we use extended segments type.
   * 
   * Departure and Arrival dates and times can be derived from the first and last segments
   *
   * @generated from field: repeated cmp.services.transport.v3.SegmentExtended segments = 4;
   */
  segments: SegmentExtended[] = [];

  constructor(data?: PartialMessage<TripExtended>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.TripExtended";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supplier_code", kind: "message", T: SupplierProductCode },
    { no: 2, name: "baggage", kind: "message", T: Baggage },
    { no: 3, name: "price", kind: "message", T: Price },
    { no: 4, name: "segments", kind: "message", T: SegmentExtended, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TripExtended {
    return new TripExtended().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TripExtended {
    return new TripExtended().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TripExtended {
    return new TripExtended().fromJsonString(jsonString, options);
  }

  static equals(a: TripExtended | PlainMessage<TripExtended> | undefined, b: TripExtended | PlainMessage<TripExtended> | undefined): boolean {
    return proto3.util.equals(TripExtended, a, b);
  }
}

/**
 * A whole trip from the first segment till the last one with basic information.
 * 
 * Intended to be used in list service.
 *
 * @generated from message cmp.services.transport.v3.TripBasic
 */
export class TripBasic extends Message<TripBasic> {
  /**
   * Trip supplier code
   *
   * @generated from field: cmp.types.v2.SupplierProductCode supplier_code = 1;
   */
  supplierCode?: SupplierProductCode;

  /**
   * Trip segments are the legs offered
   * 
   * Departure and Arrival dates and times can be derived from the first and last segments
   *
   * @generated from field: repeated cmp.services.transport.v3.Segment segments = 2;
   */
  segments: Segment[] = [];

  /**
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp last_modified = 3;
   */
  lastModified?: Timestamp;

  constructor(data?: PartialMessage<TripBasic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.TripBasic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supplier_code", kind: "message", T: SupplierProductCode },
    { no: 2, name: "segments", kind: "message", T: Segment, repeated: true },
    { no: 3, name: "last_modified", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TripBasic {
    return new TripBasic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TripBasic {
    return new TripBasic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TripBasic {
    return new TripBasic().fromJsonString(jsonString, options);
  }

  static equals(a: TripBasic | PlainMessage<TripBasic> | undefined, b: TripBasic | PlainMessage<TripBasic> | undefined): boolean {
    return proto3.util.equals(TripBasic, a, b);
  }
}

/**
 * A segment of a trip
 *
 * @generated from message cmp.services.transport.v3.SegmentExtended
 */
export class SegmentExtended extends Message<SegmentExtended> {
  /**
   * Segment Info
   *
   * @generated from field: cmp.services.transport.v3.Segment info = 1;
   */
  info?: Segment;

  /**
   * Flights, trains and transfers often offer different service types
   * for a product. Think about economy or business for flights, first and second
   * class on trains and a shared shuttle or a private transfer.
   * 
   * Service type code examples:
   * flight: "Y", "J", "F".
   * train: "1st", "2nd" or "S", "C", "P"
   * transfer: "S", "P", "VIP", "SS"
   *
   * @generated from field: string service_type_code = 2;
   */
  serviceTypeCode = "";

  /**
   * Service type description examples:
   * flight: "Economy Class", "Business Class", "First Class"
   * train: "First Class", "Second Class" or "standard", "comfort", and "premium",..
   * transfer: "Shuttle", "Private", "VIP Limosine", "Speedy Shuttle",...
   *
   * @generated from field: string service_type_description = 3;
   */
  serviceTypeDescription = "";

  /**
   * Included, optional or compulsory services for this segment or leg. Just a code and
   * description can be included if it is a package (seat, priority, large carry-on).
   * or a price detail can be included for optionally pre-ordered meals for example.
   *
   * @generated from field: repeated cmp.types.v3.ServiceFact services = 4;
   */
  services: ServiceFact[] = [];

  /**
   * Min PAX
   * 
   * Ex: `1`
   *
   * @generated from field: int32 min_pax = 5;
   */
  minPax = 0;

  /**
   * Max PAX
   * 
   * Ex: `3`
   *
   * @generated from field: int32 max_pax = 6;
   */
  maxPax = 0;

  constructor(data?: PartialMessage<SegmentExtended>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.SegmentExtended";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: Segment },
    { no: 2, name: "service_type_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "service_type_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "services", kind: "message", T: ServiceFact, repeated: true },
    { no: 5, name: "min_pax", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "max_pax", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SegmentExtended {
    return new SegmentExtended().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SegmentExtended {
    return new SegmentExtended().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SegmentExtended {
    return new SegmentExtended().fromJsonString(jsonString, options);
  }

  static equals(a: SegmentExtended | PlainMessage<SegmentExtended> | undefined, b: SegmentExtended | PlainMessage<SegmentExtended> | undefined): boolean {
    return proto3.util.equals(SegmentExtended, a, b);
  }
}

/**
 * @generated from message cmp.services.transport.v3.Segment
 */
export class Segment extends Message<Segment> {
  /**
   * Segment ID
   * Ex: "SEG1234"
   *
   * @generated from field: string segment_id = 1;
   */
  segmentId = "";

  /**
   * Provider Code Ex: "EW" for Eurowings in case of a flight. DB for Deutsche Bahn
   * in case of train. HT for Holiday Taxi or MTS for MTS in case of a transfer.
   *
   * @generated from field: string provider_code = 2;
   */
  providerCode = "";

  /**
   * Retailer Code, replacing Marketing carrier The example would be where Iberia is
   * selling an Iberia Express flight. So in this example the retailer_code for
   * Iberia would be "IB" and the provider_code for Iberia Express would be "I2".
   * Similar "interline" or "code share" operation may exist in rail and transfer.
   *
   * @generated from field: string retailer_code = 3;
   */
  retailerCode = "";

  /**
   * Sub supplier code, replacing Operating carrier or identifying sub contracted
   * services provided by other suppliers.
   * 
   * DB could be selling an international train trip operated by the Dutch Nederlands
   * Spoorwegen (NS) or the French SNCF. Holiday Taxis could be selling a transfer
   * that is operated by Transunion.
   *
   * @generated from field: string sub_supplier_code = 4;
   */
  subSupplierCode = "";

  /**
   * Product Code and Number
   * 
   * For flights we use the IATA or ICAO airline code in the code field and the
   * flight number in the number field.
   * 
   * For train some operators use a combination of a code and a number like
   * Eurostar, but others just use a code or a number (SNCF).
   * 
   * Transfers are often identified by just a product code servicing an area.
   *
   * @generated from field: cmp.types.v2.ProductCode product_code = 5;
   */
  productCode?: ProductCode;

  /**
   * Supplier specific code, matching the supplier code in ProductList and ProductInfo
   * messages
   *
   * @generated from field: cmp.types.v2.SupplierProductCode supplier_code = 6;
   */
  supplierCode?: SupplierProductCode;

  /**
   * Departure
   *
   * @generated from field: cmp.services.transport.v3.TransitEvent departure = 7;
   */
  departure?: TransitEvent;

  /**
   * Arrival
   *
   * @generated from field: cmp.services.transport.v3.TransitEvent arrival = 8;
   */
  arrival?: TransitEvent;

  /**
   * Segment duration in minutes
   *
   * @generated from field: cmp.types.v1.Duration segment_duration = 9;
   */
  segmentDuration?: Duration;

  /**
   * Segment Distance
   * 
   * Ex: `Length(value=15, unit=LengthUnit.DISTANCE_UNIT_KILOMETERS)`
   *
   * @generated from field: cmp.types.v1.Length segment_distance = 10;
   */
  segmentDistance?: Length;

  constructor(data?: PartialMessage<Segment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.Segment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "segment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "provider_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "retailer_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "sub_supplier_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "product_code", kind: "message", T: ProductCode },
    { no: 6, name: "supplier_code", kind: "message", T: SupplierProductCode },
    { no: 7, name: "departure", kind: "message", T: TransitEvent },
    { no: 8, name: "arrival", kind: "message", T: TransitEvent },
    { no: 9, name: "segment_duration", kind: "message", T: Duration },
    { no: 10, name: "segment_distance", kind: "message", T: Length },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Segment {
    return new Segment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Segment {
    return new Segment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Segment {
    return new Segment().fromJsonString(jsonString, options);
  }

  static equals(a: Segment | PlainMessage<Segment> | undefined, b: Segment | PlainMessage<Segment> | undefined): boolean {
    return proto3.util.equals(Segment, a, b);
  }
}

/**
 * Represents a departure or arrival event
 *
 * @generated from message cmp.services.transport.v3.TransitEvent
 */
export class TransitEvent extends Message<TransitEvent> {
  /**
   * Date time of the event
   * 
   * Timestamps may be used for both off-chain and on-chain operations.
   * For on-chain operations, only seconds are supported, and nanoseconds
   * will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp date_time = 1;
   */
  dateTime?: Timestamp;

  /**
   * Event location
   *
   * @generated from field: cmp.services.transport.v3.TransitEventLocation location = 2;
   */
  location?: TransitEventLocation;

  constructor(data?: PartialMessage<TransitEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.TransitEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "date_time", kind: "message", T: Timestamp },
    { no: 2, name: "location", kind: "message", T: TransitEventLocation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransitEvent {
    return new TransitEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransitEvent {
    return new TransitEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransitEvent {
    return new TransitEvent().fromJsonString(jsonString, options);
  }

  static equals(a: TransitEvent | PlainMessage<TransitEvent> | undefined, b: TransitEvent | PlainMessage<TransitEvent> | undefined): boolean {
    return proto3.util.equals(TransitEvent, a, b);
  }
}

/**
 * Represents a departure or arrival event's location
 *
 * @generated from message cmp.services.transport.v3.TransitEventLocation
 */
export class TransitEventLocation extends Message<TransitEventLocation> {
  /**
   * @generated from oneof cmp.services.transport.v3.TransitEventLocation.location
   */
  location: {
    /**
     * A location code.
     *
     * @generated from field: cmp.types.v2.LocationCode location_code = 1;
     */
    value: LocationCode;
    case: "locationCode";
  } | {
    /**
     * Single geographic point represented by two double fields.
     *
     * @generated from field: cmp.types.v2.Coordinates location_coordinates = 2;
     */
    value: Coordinates;
    case: "locationCoordinates";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TransitEventLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cmp.services.transport.v3.TransitEventLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location_code", kind: "message", T: LocationCode, oneof: "location" },
    { no: 2, name: "location_coordinates", kind: "message", T: Coordinates, oneof: "location" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransitEventLocation {
    return new TransitEventLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransitEventLocation {
    return new TransitEventLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransitEventLocation {
    return new TransitEventLocation().fromJsonString(jsonString, options);
  }

  static equals(a: TransitEventLocation | PlainMessage<TransitEventLocation> | undefined, b: TransitEventLocation | PlainMessage<TransitEventLocation> | undefined): boolean {
    return proto3.util.equals(TransitEventLocation, a, b);
  }
}

